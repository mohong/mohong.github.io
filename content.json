{"meta":{"title":"墨鸿的博客","subtitle":"墨鸿的博客","description":"墨鸿的博客,html,css,js,git,nodejs,java,linux,摄影","author":"墨鸿","url":"http://arthas.com.cn"},"pages":[{"title":"关于","date":"2017-09-01T15:49:02.000Z","updated":"2018-06-27T15:26:39.106Z","comments":true,"path":"about/index.html","permalink":"http://arthas.com.cn/about/index.html","excerpt":"","text":".my-avatar { width: 100px; height: 100px; border-radius: 100%; } .my-info { width: 70%; text-align: left; } 2018-04思考人生 2016-08北京你好 2015-06巨浪滚滚入海，各奔天涯。"},{"title":"tools","date":"2018-07-17T12:38:02.000Z","updated":"2018-08-29T06:48:23.678Z","comments":true,"path":"tools/index.html","permalink":"http://arthas.com.cn/tools/index.html","excerpt":"","text":"工具集 json格式化 在线缩小 MP3 文件尺寸 免费的图标库 vue-fontawesome"}],"posts":[{"title":"JavaScript数组转树结构","slug":"JavaScript数组转树结构","date":"2018-10-24T13:43:22.000Z","updated":"2018-10-24T13:52:07.828Z","comments":true,"path":"2018/10/24/JavaScript数组转树结构/","link":"","permalink":"http://arthas.com.cn/2018/10/24/JavaScript数组转树结构/","excerpt":"","text":"对于带有树结构性质的数组，例如元素中含有id和parentId，经常需要处理成树形结构来处理业务。比如多级导航，遍历文件夹等。用遍历的方式实现转换方法： 12345678910111213141516171819/*** data 数组数据* pid 顶级元素的parentId值*/function array2Tree (data, pid) &#123; let result = [] let temp for (let i = 0; i &lt; data.length; i++) &#123; if (data[i].parentId === pid) &#123; let obj = &#123;id: data[i].id, name: data[i].name&#125; temp = array2Tree(data, data[i].id) if (temp.length &gt; 0) &#123; obj.children = temp &#125; result.push(obj) &#125; &#125; return result&#125; 参考文章： js递归实现数组转树结构（多级菜单应用）","categories":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://arthas.com.cn/tags/javascript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}]},{"title":"BFC布局介绍","slug":"BFC布局介绍","date":"2018-10-10T09:37:21.000Z","updated":"2018-10-12T07:57:41.463Z","comments":true,"path":"2018/10/10/BFC布局介绍/","link":"","permalink":"http://arthas.com.cn/2018/10/10/BFC布局介绍/","excerpt":"","text":"BFC全称block formatting context，中文为“块级格式化上下文”。如果一个元素具有BFC，则内部元素不会影响到外部元素。所以BFC元素是不可能发生margin重叠的，因为margin重叠会影响到外部的元素；BFC元素也可用用来清除浮动的影响，因为如果不清除，子元素浮动则父元素高度塌陷。必然会影响元素的布局和定位。 以下条件会触发BFC： &lt;html&gt;根元素 float的值不为none时 overflow的值为auto、scroll和hidden display的值为table-cell、table-caption、inline-block中的任何一个 position的值不为relative和static 换言之，只要元素符合上面任一条件，就无需使用clear:both的属性去清除浮动的影响了。 以下是一个\b图片浮动的例子： 可以看到文字和图片出现了\b环绕效果。如果我们想让文字和图片隔开该如何实现？只需要设置文字部分为BFC元素： 123.animal &#123; overflow: hidden;&#125; 用BFC实现一个两列布局会简单很多： 1234&lt;div class=\"bfc\"&gt; &lt;div class=\"left side\"&gt;左侧&lt;/div&gt; &lt;div class=\"bfc\"&gt;主体内容&lt;/div&gt;&lt;/div&gt; 123456789.bfc &#123; overflow: hidden;&#125;.left &#123; float: left;&#125;.side &#123; width: 200px;&#125; 摘自张鑫旭《CSS世界》一书","categories":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://arthas.com.cn/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}]},{"title":"CSS计数器","slug":"CSS计数器","date":"2018-10-09T06:51:22.000Z","updated":"2018-10-09T07:13:01.834Z","comments":true,"path":"2018/10/09/CSS计数器/","link":"","permalink":"http://arthas.com.cn/2018/10/09/CSS计数器/","excerpt":"","text":"CSS 计数器本质上是 CSS 维护的变量，这些变量可以根据 CSS 规则增加以跟踪使用次数。 语法1.命名变量并定义计数器的值，默认为 0。表示定义了varname计数器，从2开始计数 1counter-reset: varname 2; 2.递增计数器的值，默认增量为 1。 1counter-increment: varname; 3.counter() / counters() 方法显示计数。和伪元素before/after配合使用。 1counter(varname); 案例1、统计点击按钮 2、文章序号自动递增 3、文章序号掏钱递增 参考文章使用 CSS 计数器","categories":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://arthas.com.cn/tags/CSS/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}]},{"title":"贪心算法","slug":"贪心算法","date":"2018-09-18T08:16:48.000Z","updated":"2018-09-27T12:46:55.720Z","comments":true,"path":"2018/09/18/贪心算法/","link":"","permalink":"http://arthas.com.cn/2018/09/18/贪心算法/","excerpt":"","text":"贪心算法简介 贪心算法是指：在每一步求解的步骤中，它要求“贪婪”的选择最佳操作，并希望通过一系列的最优选择，能够产生一个问题的（全局的）最优解。 贪心算法每一步必须满足以下条件： 可行的：即它必须满足问题的约束 局部最优：他是当前步骤中所有可行选择中最佳的局部选择 不可取消：即选择一旦做出，在算法的后面步骤就不可改变了 贪心法在解决问题的策略上目光短浅，仅仅依据当前已有的信息就做出选择，并且一旦做出了选择，无论将来有什么结果，这个选择都不会改变。一句话：不求最优，仅仅求可行解。对于一个详细的问题，怎么知道是否可用贪心算法解此问题，以及是否能得到问题的最优解? 我们能够依据贪心法的2个重要的性质去证明：贪心选择性质和最优子结构性质： 贪心选择什么叫贪心选择？从字义上就是贪心也就是目光短线。贪图眼前利益。在算法中就是仅仅依据当前已有的信息就做出选择，并且以后都不会改变这次选择。（这是和动态规划法的主要差别） 最优子结构当一个问题的最优解包括其子问题的最优解时，称此问题具有最优子结构性质。这个性质和动态规划法的一样，最优子结构性质是可用动态规划算法或贪心算法求解的关键特征。 贪心算法案例1、活动选择问题这是《算法导论》上的例子，也是一个非常经典的问题。有n个需要在同一天使用同一个教室的活动a1,a2,…,an，教室同一时刻只能由一个活动使用。每个活动ai都有一个开始时间si和结束时间fi 。一旦被选择后，活动ai就占据半开时间区间[si,fi)。如果[si,fi]和[sj,fj]互不重叠，ai和aj两个活动就可以被安排在这一天。该问题就是要安排这些活动使得尽量多的活动能不冲突的举行。例如下图所示的活动集合S，其中各项活动按照结束时间单调递增排序。 用贪心法的话思想很简单：活动越早结束，剩余的时间是不是越多？那我就早最早结束的那个活动，找到后在剩下的活动中再找最早结束的不就得了？ java代码实现： ActiveTime.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class ActiveTime &#123; public static void main(String[] args) &#123; //创建活动并添加到集合中 Active act1 = new Active(1, 4); Active act2 = new Active(3, 5); Active act3 = new Active(0, 6); Active act4 = new Active(5, 7); Active act5 = new Active(3, 8); Active act6 = new Active(5, 9); Active act7 = new Active(6, 10); Active act8 = new Active(8, 11); Active act9 = new Active(8, 12); Active act10 = new Active(2, 13); Active act11 = new Active(12, 14); List&lt;Active&gt; actives = new ArrayList&lt;Active&gt;(); actives.add(act1); actives.add(act2); actives.add(act3); actives.add(act4); actives.add(act5); actives.add(act6); actives.add(act7); actives.add(act8); actives.add(act9); actives.add(act10); actives.add(act11); List&lt;Active&gt; bestActives = getBestActives(actives, 0, 16); for (int i = 0; i &lt; bestActives.size(); i++) &#123; System.out.println(bestActives.get(i)); &#125; &#125; /** * * @param actives 活动集合 * @param startTime 教室的开始使用时间 * @param endTime 教室的结束使用时间 * @return */ public static List&lt;Active&gt; getBestActives(List&lt;Active&gt; actives, int startTime, int endTime) &#123; //最佳活动选择集合 List&lt;Active&gt; bestActives = new ArrayList&lt;Active&gt;(); //将活动按照最早结束时间排序 actives.sort(null); //nowTime 用来记录上次活动结束时间 int nowTime = startTime; /** * 因为我们已经按照最早结束时间排序，那么只要活动在时间范围内 * actives.get(1)就应当是第一个活动的结束时间. * 则我们记录第一次活动结束的时间，在结合剩下的活动中， * 选取开始时间大于nowTime且结束时间又在范围内的活动，则为第二次活动时间， * 知道选出所有活动 */ for (int i = 0; i &lt; actives.size(); i++) &#123; Active act = actives.get(i); if(act.getStartTime()&gt;=nowTime&amp;&amp;act.getEndTime()&lt;=endTime)&#123; bestActives.add(act); nowTime = act.getEndTime(); &#125; &#125; return bestActives; &#125;&#125; Active.java 12345678910111213141516171819202122232425262728293031323334353637383940414243class Active implements Comparable&lt;Active&gt;&#123; private int startTime;//活动开始时间 private int endTime;//活动结束时间 public Active(int startTime, int endTime) &#123; super(); this.startTime = startTime; this.endTime = endTime; &#125; public int getStartTime() &#123; return startTime; &#125; public void setStartTime(int startTime) &#123; this.startTime = startTime; &#125; public int getEndTime() &#123; return endTime; &#125; public void setEndTime(int endTime) &#123; this.endTime = endTime; &#125; @Override public String toString() &#123; return \"Active [startTime=\" + startTime + \", endTime=\" + endTime + \"]\"; &#125; //活动排序时按照结束时间升序 @Override public int compareTo(Active o) &#123; if(this.endTime&gt;o.getEndTime())&#123; return 1; &#125;else if(this.endTime == o.endTime)&#123; return 0; &#125;else&#123; return -1; &#125; &#125;&#125; 运行结果： 1234Active [startTime=1, endTime=4]Active [startTime=5, endTime=7]Active [startTime=8, endTime=11]Active [startTime=12, endTime=14] 2、买彩票的问题这是leetcode上的一道题：122. 买卖股票的最佳时机 II 题解：只要后一天的价格比之前高就卖出，这样才能赚。 1234567891011class Solution &#123; public int maxProfit(int[] prices) &#123; int sum = 0; for (int i = 0; i &lt; prices.length - 1; i++) &#123; if (prices[i] &lt; prices[i + 1]) &#123; sum = sum + prices[i + 1] - prices[i]; &#125; &#125; return sum; &#125;&#125; 3、分饼干问题 贪心算法通常和排序是分不开的，如果题目给出数组没有排序，我们就需要自己进行排序。 leecode第455题分发饼干 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 题解： 1234567891011121314151617public static int findContentChildren(int[] g, int[] s) &#123; Arrays.sort(g); Arrays.sort(s); int res = 0; int i = 0; int j = 0; while (i &lt; g.length &amp;&amp; j &lt; s.length) &#123; if (g[i] &lt;= s[j]) &#123; res++; i++; j++; &#125; else &#123; j++; &#125; &#125; return res;&#125; 参考资料 五大常用算法之三贪心算法 五大算法思想—贪心算法","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://arthas.com.cn/categories/编程基础/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://arthas.com.cn/tags/Algorithms/"}],"keywords":[{"name":"编程基础","slug":"编程基础","permalink":"http://arthas.com.cn/categories/编程基础/"}]},{"title":"Delete Node in a Linked List","slug":"Delete-Node-in-a-Linked-List","date":"2018-09-17T02:54:34.000Z","updated":"2018-09-17T12:58:00.727Z","comments":true,"path":"2018/09/17/Delete-Node-in-a-Linked-List/","link":"","permalink":"http://arthas.com.cn/2018/09/17/Delete-Node-in-a-Linked-List/","excerpt":"","text":"leetcode第237号题Delete Node in a Linked List，从链表中删除一个节点。刚看到这个题目还以为是题目出错了，因为要删除一个一个节点，至少题设要告诉链表的头结点和需要删除的节点。查阅之后才明白并不是题目出错，而是自己思路理解有误。在没有告知头结点的情况下，只告诉要删除的节点，也是可以删除的。原理就是用把当前传入的节点(即需要删除的节点)用其下一个节点覆盖掉。 因为题目中已告知： 该链表至少两个节点 所有节点的值均唯一 给出的节点不会是最后的尾节点并且一定是有效节点 不要返回任何值 题解代码： 1234public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next;&#125;","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://arthas.com.cn/categories/编程基础/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://arthas.com.cn/tags/leetcode/"}],"keywords":[{"name":"编程基础","slug":"编程基础","permalink":"http://arthas.com.cn/categories/编程基础/"}]},{"title":"JavaScript中apply、call 的区别","slug":"JavaScript中apply、call-的区别","date":"2018-09-03T07:33:30.000Z","updated":"2018-09-09T14:52:14.443Z","comments":true,"path":"2018/09/03/JavaScript中apply、call-的区别/","link":"","permalink":"http://arthas.com.cn/2018/09/03/JavaScript中apply、call-的区别/","excerpt":"","text":"在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。JavaScript 的一大特点是，函数存在定义时上下文和运行时上下文以及上下文是可以改变的这样的概念。 先来一个栗子： 1234567891011function fruits() &#123;&#125; fruits.prototype = &#123; color: \"red\", say: function() &#123; console.log(\"My color is \" + this.color); &#125;&#125; var apple = new fruits;apple.say(); //My color is red 但是如果我们有一个对象banana= {color : “yellow”} ,我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法：12345banana = &#123; color: \"yellow\"&#125;apple.say.call(banana); //My color is yellowapple.say.apply(banana); //My color is yellow 所以，可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 object 没有某个方法（本栗子中banana没有say方法），但是其他的有（本栗子中apple有say方法），我们可以借助call或apply用其它对象的方法来操作。 apply、call 的区别对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。 第一个参数均为执行时的this对象，call需要把参数按顺序传递进去，而apply 则是把参数放在数组里。 JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call 。而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个伪数组来遍历所有的参数。 应用将伪数组转换为数组 1数组 = Array.prototype.slice.call(伪数组)) 判断参数类型 12345678Object.prototype.toString.call(&#123;&#125;)// \"[object Object]\"Object.prototype.toString.call([3, 5, 7])// \"[object Array]\"Object.prototype.toString.call(2)// \"[object Number]” 参考资料： 【优雅代码】深入浅出 妙用Javascript中apply、call、bind","categories":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://arthas.com.cn/tags/javascript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}]},{"title":"vue-cli多环境打包配置","slug":"vue-cli多环境打包配置","date":"2018-08-23T06:11:09.000Z","updated":"2018-09-03T06:24:46.378Z","comments":true,"path":"2018/08/23/vue-cli多环境打包配置/","link":"","permalink":"http://arthas.com.cn/2018/08/23/vue-cli多环境打包配置/","excerpt":"","text":"通过npm run build打包之后的静态项目，可能部署在不同环境中，即提供数据的api也是多变的。需要根据配置在打包时动态生成。假设需求是需要打包测试环境和生产环境两套静态文件： 1、package.json中script部门定义test_build、production_build两条指令，并给node环境变量中增加了环境变量BUILD_ENV 1234567\"scripts\": &#123; \"dev\": \"webpack-dev-server --disableHostCheck=true --inline --progress --config build/webpack.dev.conf.js\", \"start\": \"npm run dev\", \"build\": \"node build/build.js\", \"test_build\": \"BUILD_ENV=test node build/build.js\", \"production_build\": \"BUILD_ENV=production node build/build.js\"&#125; 2、./build/build.js中增加并修改以下代码，用于加载不同文件： 1234567891011121314151617181920212223242526272829303132'use strict'require('./check-versions')()process.env.NODE_ENV = 'production'const ora = require('ora')const rm = require('rimraf')const path = require('path')const chalk = require('chalk')const webpack = require('webpack')const config = require('../config')// 增加部分let webpackConfigFilePath = ''switch (process.env.BUILD_ENV) &#123; case 'test': webpackConfigFilePath = './webpack.test.conf'; break; case 'production': webpackConfigFilePath = './webpack.prod.conf'; break; default: webpackConfigFilePath = './webpack.prod.conf';&#125;// 修改加载文件路径const webpackConfig = require(webpackConfigFilePath)// 原脚手架代码const spinner = ora('building for production...')spinner.start()rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123; // ......&#125;) 3、修改./build文件夹下增加webpack.prod.conf.js。\bplugins中webpack.DefinePlugin插件下定义的变量可以在项目中作为全局变量直接使用。比如生产环境中的配置： 123456789101112131415161718// ...plugins: [ // http://vuejs.github.io/vue-loader/en/workflow/production.html new webpack.DefinePlugin(&#123; 'process.env': env, 'HTTP_API': '\"prod.api.com\"' &#125;), new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false &#125; &#125;, sourceMap: config.build.productionSourceMap, parallel: true &#125;)]// ... 测试环境将’\bHTTP_API’的值改为测试\b环境的接口。注意该需要用引号引起来，因为解析的时候不会自定转为字符串。是&#39;&quot;prod.api.com&quot;&#39;不是&#39;prod.api.com&#39;; 4、直接在项目中使用HTTP_API全局变量即可。例如使用axios库时： 1axios.defaults.baseURL = \bHTTP_API","categories":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://arthas.com.cn/tags/vue/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}]},{"title":"vue封装的svg圆形进度条","slug":"vue封装的svg圆形进度条","date":"2018-06-26T14:31:17.000Z","updated":"2018-06-26T14:59:39.973Z","comments":true,"path":"2018/06/26/vue封装的svg圆形进度条/","link":"","permalink":"http://arthas.com.cn/2018/06/26/vue封装的svg圆形进度条/","excerpt":"","text":"可缩放矢量图形（Scalable Vector Graphics，SVG)，是一种用来描述二维矢量图形的 XML 标记语言。 简单地说，SVG 面向图形，HTML 面向文本。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div class=\"progress-circle\"&gt; &lt;svg :width=\"radius\" :height=\"radius\" viewBox=\"0 0 100 100\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;circle class=\"progress-background\" cx=\"50\" cy=\"50\" r=\"50\" fill=\"transparent\"/&gt; &lt;circle class=\"progress-bar\" cx=\"50\" cy=\"50\" r=\"50\" fill=\"transparent\" :stroke-dasharray=\"dashArray\" :stroke-dashoffset=\"dashOffset\" /&gt; &lt;/svg&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=\"text/ecmascript-6\"&gt;export default &#123; props: &#123; percent: &#123; type: Number, default: 0 &#125;, radius: &#123; type: String, default: 100 &#125; &#125;, data() &#123; return &#123; dashArray: Math.PI * 100 &#125; &#125;, computed: &#123; dashOffset() &#123; return (1 - this.percent) * this.dashArray &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped lang=\"stylus\"&gt; .progress-circle position: relative circle transform-origin: center stroke-linecap: round &amp;.progress-background stroke-width: 5px stroke: #e7eef2 transform: scale(0.9) &amp;.progress-bar stroke-width: 8px transform: scale(0.9) rotate(-90deg) transition: stroke-dashoffset 0.5s ease; stroke: #00b04d&lt;/style&gt; 使用： 1&lt;progress-circle radius=\"100px\" :percent=\"0.6\"&gt;&lt;/progress-circle&gt; 注意：如果要看到下面的动画效果，需要将percent参数设置为变量，然后修改其值。 效果： 推荐阅读：纯CSS实现帅气的SVG路径描边动画效果","categories":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}],"tags":[{"name":"svg","slug":"svg","permalink":"http://arthas.com.cn/tags/svg/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}]},{"title":"nodejs日志框架winston配置","slug":"nodejs日志框架winston配置","date":"2018-06-22T01:27:20.000Z","updated":"2018-06-23T03:19:36.064Z","comments":true,"path":"2018/06/22/nodejs日志框架winston配置/","link":"","permalink":"http://arthas.com.cn/2018/06/22/nodejs日志框架winston配置/","excerpt":"","text":"一、日志级别：winston是为nodejs开发的日志框架。winston默认定义了6中状态，级别由高到低依次是：error、warn、info、verbose、debug、silly。 二、 输出策略 运行日志根据日期命名，例如‘app-2018-06-19.log’ 支持自定义保存天数，目前定义14天，不配置可不删除旧文件 日期格式化：‘YYYY-MM-DD HH:mm:ss’ 日志输入格式：json ‘error’级日志独立输出 支持控制台输出 三、 logger对象的接口 logger.error( msg ) : 打印error级别的日志 logger. warn( msg )：打印warn级别的日志 logger.info( msg ) : 打印info级别的日志 logger. verbose( msg )：打印verbose （冗长的） 级别的日志 logger. debug( msg )：打印debug级别的日志 logger. silly( msg )：打印silly（愚蠢的）基本的日志 四、 代码配置定义logger.js文件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const winston = require('winston');require('winston-daily-rotate-file')// 错误信息日志const ERROR_LOG_NAME = './logs/error.log';// 所有运行日志const APP_LOG_NAME = './logs/app-%DATE%.log'// 保存天数const SAVE_DAYS = '14d'// 日志级别const levels = &#123; error: 0, warn: 1, info: 2, verbose: 3, debug: 4, silly: 5&#125;// 格式化输出内容const formatter = winston.format.combine( winston.format.json(), winston.format.timestamp(&#123; format: 'YYYY-MM-DD HH:mm:ss' &#125;), winston.format.printf(info =&gt; &#123; // 输出格式 // TODO message字段是Symbol对象，对于error级的日志，需要遍历message的Symbol拿到error对象 const showInfo = &#123; time: info.timestamp, pid: process.pid, level: info.level, message: info.message&#125;; return JSON.stringify(showInfo) &#125;))const logger = winston.createLogger(&#123; levels: levels, format: formatter, transports: [ // 'error'级别的日志处理 new winston.transports.File(&#123; level: 'error', filename: ERROR_LOG_NAME &#125;), // '所有的日志处理, maxFiles是回滚时间，超时会删除旧文件，如果不设置，则不会删除' new (winston.transports.DailyRotateFile)(&#123; filename: APP_LOG_NAME, zippedArchive: true, maxFiles: SAVE_DAYS &#125;), // 控制台输出 new winston.transports.Console(&#123;&#125;) ]&#125;);module.exports = logger; 将事件转换为GMT时间 12345678910// 格式化输出内容const formatter = winston.format.combine( // 参数Z将指定时间为GMT时间，即格林尼治时间 winston.format.timestamp(&#123; format: 'YYYY-MM-DD HH:mm:ss Z'&#125;), // &#123; format: 'YYYY-MM-DD HH:mm:ss' &#125; winston.format.printf(info =&gt; &#123; // 输出格式 const showInfo = &#123; time: new Date(info.timestamp).toUTCString(), pid: process.pid, level: info.level, message: info.message&#125;; return JSON.stringify(showInfo) &#125;))","categories":[{"name":"后端","slug":"后端","permalink":"http://arthas.com.cn/categories/后端/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://arthas.com.cn/tags/nodejs/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://arthas.com.cn/categories/后端/"}]},{"title":"用stylus写CSS","slug":"用stylus写CSS","date":"2018-06-21T09:47:58.000Z","updated":"2018-06-21T10:16:56.716Z","comments":true,"path":"2018/06/21/用stylus写CSS/","link":"","permalink":"http://arthas.com.cn/2018/06/21/用stylus写CSS/","excerpt":"","text":"1、定义变量对于项目全局统一使用的主题色，可以定义成变量。 variable.styl文件： 1$color-grey = #666 需要使用的文件： 1234@import \"../stylus/variable.styl\".item color: $font-color 2、定义方法对于重复用到的样式块，可以定义成一个方法，使用的时候直接传变量即可。 mixin.styl文件： 12bg-image($url) background-image: url($url) 需要使用的文件： 1234@import \"../stylus/variable.styl\".item bg-image(\"pic.png\")","categories":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://arthas.com.cn/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}]},{"title":"websocket长连接及心跳实现","slug":"websocket长连接及心跳实现","date":"2018-04-23T12:30:07.000Z","updated":"2018-06-21T10:22:00.333Z","comments":true,"path":"2018/04/23/websocket长连接及心跳实现/","link":"","permalink":"http://arthas.com.cn/2018/04/23/websocket长连接及心跳实现/","excerpt":"","text":"WebSocket 是一种网络通信协议，很多高级功能都需要它。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。ws是一个nodejs的websocket实现，通过这个包可以创建一个简单的websocket服务： 创建websocket长连接服务服务端 123456789101112131415161718192021222324const WebSocketServer = require('ws').Server;const wss = new WebSocketServer(&#123; port: 8082 &#125;);wss.on('connection', function connection(ws) &#123; console.log('会话已建立'); ws.on('message', function incoming(message) &#123; console.log('received: %s', message); &#125;); const timer = setInterval(() =&gt; &#123; const info = 'I`m server info'; console.log(info); ws.send(info); &#125;, 3000); ws.on('error', function () &#123; console.log('error'); &#125;); ws.on('close', function (reson) &#123; console.log('close', reson); clearInterval(timer); &#125;);&#125;); 客户端 index.html 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"show\"&gt;&lt;/div&gt; &lt;script&gt; var count = 0; var url = \"ws://192.168.199.131:8082\"; var ws = new WebSocket(url); ws.onopen = function(event) &#123; console.log('和服务端建立连接'); &#125; ws.onerror = function (params) &#123; console.log(params); &#125; ws.onmessage = function(event) &#123; var showData = count++ + ' ' + event.data; document.querySelector('#show').innerHTML = showData; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器打开index.html并观察控制台，可以看到服务端发送过来的信息 此时手机和电脑连接到同一个网络，手机访问也是可以实现连接。 但是目前的服务存在以下问题： 长时间不发送数据，运营商或者部分防火墙会关闭该连接，服务端无感知 客户端和服务端之间断开网络，服务端无感知 服务端会继续向客户端发送数据，导致服务端连接不能及时关闭造成资源占用和数据丢失。可以试试在手机访问的时候，断开手机网络，服务端依然给发送数据。 所以需要心跳包来监测客户端是否在线。 心跳包心跳包的实现原理： websocket协议定义了心跳机制，一方可以通过发送ping（opcode 0x9）消息给另一方，另一方收到ping后应该尽可能快的返回pong（0xA）。 如果客户端支持ping，最好由客户端发起ping，然后服务器记录时间，超时断开即可。浏览器中没有相关api发送ping给服务器，只能由服务器发ping给浏览器。 对上述服务端代码进行改进，加入心跳机制，每隔3s从服务端发送ping，浏览器在收到之后给服务器回复pong，服务端监听pong： 12345678910111213141516171819202122232425262728293031323334353637383940414243const WebSocketServer = require('ws').Server;const wss = new WebSocketServer(&#123; port: 8082 &#125;);function noop() &#123; console.log('noop');&#125;function heartbeat() &#123; this.isAlive = true;&#125;wss.on('connection', function connection(ws) &#123; console.log('会话已建立'); const timer = setInterval(() =&gt; &#123; const info = 'I`m server info'; console.log(info); ws.send(info); &#125;, 3000); ws.isAlive = true; ws.on('pong', heartbeat); const interval = setInterval(function ping() &#123; wss.clients.forEach(function each(ws) &#123; if (ws.isAlive === false) &#123; return ws.terminate(); &#125; ws.isAlive = false; ws.ping(noop); &#125;); &#125;, 3000); ws.on('message', function incoming(message) &#123; console.log('received: %s', message); &#125;); ws.on('error', function () &#123; console.log('error'); &#125;); ws.on('close', function (reson) &#123; clearInterval(timer); console.log('close', reson); &#125;);&#125;); 通过抓包可以看到ping pong的过程： 这样当收不到浏览器的时候，由于isAlive为false，会执行ws.terminate()关闭连接和其他清理工作。 参考资料 websocket ,ping pong heardbeat心跳机制 ws doc websocket教程","categories":[{"name":"网络","slug":"网络","permalink":"http://arthas.com.cn/categories/网络/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"http://arthas.com.cn/tags/websocket/"}],"keywords":[{"name":"网络","slug":"网络","permalink":"http://arthas.com.cn/categories/网络/"}]},{"title":"JavaScript中的闭包","slug":"JavaScript中的闭包","date":"2018-03-30T08:44:34.000Z","updated":"2018-03-30T13:10:04.850Z","comments":true,"path":"2018/03/30/JavaScript中的闭包/","link":"","permalink":"http://arthas.com.cn/2018/03/30/JavaScript中的闭包/","excerpt":"","text":"1、变量作用域一个变量的作用域（scope）是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，在JavaScript代码中的任何地方都是有定义的。然而在函数内声明的变量只在函数体内有定义。它们是局部变量，作用域是局部性的。函数参数也是局部变量，它们只在函数体内有定义。 在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所遮盖。 1234567var scope = 'global';function checkScope() &#123; var scope = 'local'; console.log(scope); // local&#125;checkScope() 声明局部变量时必须使用var，否则该操作会创建全局变量。函数定义是可以嵌套的。由于每个函数都有它自己的作用域，因此会出现几个局部作用域嵌套的情况，例如： 12345678910var scope = 'global scope';function checkScope() &#123; var scope = 'local scope'; function nested() &#123; var scope = 'nested scope'; return scope; &#125; return nested();&#125;checkScope() // nested scope 1.1、函数作用域和声明提前在一些类似C语言的编程语言中，花括号内的每一段代码都是具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，我们称为块级作用域（block scope），而JavaScript中没有块级作用域。JavaScript取而代之地使用了函数作用域（function scope）：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是定义的。 在如下所示的代码中，在不同位置定义了变量i，j和k，它们都在同一个作用域内——这三个变量在函数体内均是有定义的。 1234567891011function test(o) &#123; var i = 0; // i在整个函数体内都是有定义的 if (typeof o == 'object') &#123; var j = 0; // j在整个函数体内是有定义的，不仅仅是在这个代码段内 for (var k = 0; k &lt; 10; k++) &#123; // k在函数体内是有定义的，不仅仅是在这个代码段内 console.log(k); // 输出数字0-9 &#125; console.log(k); // k已经定义了，输出数字10 &#125; console.log(j); // j已经定义了，但是可能没有初始化&#125; JavaScript的函数作用域是指在函数体内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至已经可用。JavaScript的这个特性被非正式的称为声明提前(hoisting，或者变量提升)，即JavaScript函数里声明的所有变量（但不涉及赋值）都被“提前”至函数体的顶部，看如下代码： 123456var scope = 'global';function f() &#123; console.log(scope); // 输出undefined，而不是global var scope = 'local'; // 变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的 console.log(scope); // 输出local&#125; 以上代码相当于如下代码： 1234567var scope = 'global';function f() &#123; var scope console.log(scope); scope = 'local'; console.log(scope);&#125; 所以一些程序员特意将变量声明放在函数体顶部。 1.2、作为属性的变量当声明一个JavaScript全局变量时，实际上是定义了全局对象的一个属性。当使用var声明一个变量时，创建的这个属性是不可配置的，也就是说这个变量无法通过delete运算符删除。如果没有使用严格模式并给一个未声明的变量赋值的话，JavaScript会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配置属性，并可以删除它们。 JavaScript全局变量是全局对象的属性，这是在ECMAScript规范中强制规定的。对于局部变量则没有如此规定，但我们可以想象得到，局部变量当做跟函数调用相关的某个对象的属性，局部变量当做跟函数调用相关的某个对象的属性。ECMAScript3规范称该对象为调用对象，ECMAScript5规范称为声明上下文对象。JavaScript可以允许使用this关键字来引用全局对象，却没有方法可以引用局部变量中存放的对象。 2、闭包JavaScript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为“闭包”。 从技术的角度讲，所有的JavaScript函数都是闭包：它们都是对象，它们都关联到作用域链。当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，事情就变的非常微妙。当一个函数调用了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。 12345678910var scope = 'global scope';function checkScope() &#123; var scope = 'local scope'; function f() &#123; return scope; &#125; return f();&#125;checkScope() // 返回local scope 12345678910var scope = 'global scope';function checkScope() &#123; var scope = 'local scope'; function f() &#123; return scope; &#125; return f;&#125;checkScope()() // 返回local scope 在这段代码中，我们将函数内的一对圆括号移动到了checkScope()之后。checkScope()现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数(包含最后一行代码的最后一对圆括号)会发生什么事情呢？ 回想一下词法作用域的基本规则，JavaScript函数的执行用到了作用域链，这个作用域链是函数定义的时候创建的。嵌套的函数f()定义在这个作用域链里，其中的变量scope一定是局部变量，不管在何时何地执行函数f()，这种绑定在执行f()时依然有效。因此最后一行代码返回“local scope”而不是“global scope”。简言之，闭包的这个特性强大到让人吃惊：它们可以捕捉到局部变量（和参数），并一直保存下来，看起来像这些变量绑定到了在其中定义它们的外部函数。 参考资料《JavaScript权威指南》","categories":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://arthas.com.cn/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}]},{"title":"求第k大问题的解法","slug":"求第k大问题的解法","date":"2018-03-15T06:38:42.000Z","updated":"2018-03-15T07:16:11.475Z","comments":true,"path":"2018/03/15/求第k大问题的解法/","link":"","permalink":"http://arthas.com.cn/2018/03/15/求第k大问题的解法/","excerpt":"","text":"leetcode第215号题目Kth Largest Element in an Array Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.For example,Given [3,2,1,5,6,4] and k = 2, return 5. 典型的求第K大问题，先上解法 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public static int findKthLargest(int nums[], int k) &#123; return solve(nums, 0, nums.length - 1, k - 1); &#125; // 对arr[l, r]部分进行partition操作 private static int partition(int[] arr, int l, int r) &#123; if (l == r) &#123; return arr[l]; &#125; // 随机交换位置 swap(arr, l, (int)(Math.random() * (r - l + 1) + l)); int v = arr[l]; int j = l; for (int i = l + 1; i &lt;= r; i++) &#123; if (arr[i] &gt; v) &#123; j++; swap(arr, j, i); &#125; &#125; swap(arr, l, j); return j; &#125; // 求出nums[l, r]范围里第k大的数 private static int solve(int nums[], int l, int r, int k) &#123; if (l == r) &#123; return nums[l]; &#125; int p = partition(nums, l, r); if (k == p) &#123; return nums[p]; &#125; else if (k &lt; p) &#123; return solve(nums, l, p - 1, k); &#125; else &#123; return solve(nums, p + 1, r, k); &#125; &#125; private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 该解法的思路是快速排序中的思想，利用partition函数对数组进行分解。 int p = partition(nums, l, r) 此时p位置的数值已经排好了序，即p就是nums[p]的索引值。 在solve方法中，利用p值将数组分为两部分，如果k等于p，则nums[p]正是所求的第k大值；如果k大于p，则表示第k大值在p的右半部分，再次进入solve进行递归查找；如果k小于p，同理，在p的左侧进行递归查找。","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://arthas.com.cn/categories/编程基础/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://arthas.com.cn/tags/Algorithms/"}],"keywords":[{"name":"编程基础","slug":"编程基础","permalink":"http://arthas.com.cn/categories/编程基础/"}]},{"title":"CSS之布局","slug":"CSS之布局","date":"2018-03-14T06:24:28.000Z","updated":"2018-03-14T06:26:46.953Z","comments":true,"path":"2018/03/14/CSS之布局/","link":"","permalink":"http://arthas.com.cn/2018/03/14/CSS之布局/","excerpt":"","text":"所有CSS布局技术的根本都是3个基本概念：定位、浮动和外边距操纵 计划布局 检查设计，寻找重复的模式， 注意结构和意义 标注设计稿 定义元素 设置基本结构比如一个典型的三列博客模板 12345678910111213&lt;body&gt; &lt;div class=\"wrapper&gt; &lt;div class=\"header&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 使用外边距让设计居中 1234.wrapper &#123; width: 920px; margin: 0 auto;&#125; 基于浮动的布局当使用浮动时，他们不再在文档流中占据任何空间，这会导致页脚向上升，为了避免这种情况，需要对他们的父元素应用溢出方法，从而清除浮动元素。 123.content &#123; overflow: hidden;&#125; 流式布局在使用流式布局时，尺寸是用百分数而不是像素设置的，这使流式布局能够相对于浏览器窗口进行伸缩。但是在窗口缩小时，行变得非常窄，很难阅读，在多列布局中尤其如此。因此，有必要添加像素或者em为单位的mix-width，从而防止布局变得太窄，但是如果mix-width设置的太大，流式设计也会遇到与固定宽度布局相同的限制。 弹性布局弹性布局相对于字号（而不是浏览器宽度）来设置浏览器宽度。以em为单位设置宽度，可以确保在字号增大时整个布局随之扩大，","categories":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://arthas.com.cn/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}]},{"title":"CSS之盒子模型","slug":"CSS之盒子模型","date":"2018-03-14T06:21:06.000Z","updated":"2018-03-14T06:22:24.809Z","comments":true,"path":"2018/03/14/CSS之盒子模型/","link":"","permalink":"http://arthas.com.cn/2018/03/14/CSS之盒子模型/","excerpt":"","text":"盒模型概述 增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的尺寸 如果在元素上添加背景，那么背景会应用于由内容和内边距组成的区域 外边框是透明的，一般是用他控制元素之间的间距 outline（轮廓）绘制元素框之上，不影响元素的大小或定位 IE和盒模型自从1996年CSS1的推出，W3C组织就建议把所有网页上的对像都放在一个盒(box)中，设计师可以通过创建定义来控制这个盒的属性，这些对像包括段落、列表、标题、图片以及层在W3C盒模型中，一个块级元素的总宽度按照如下的方程式计算： 1总宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right IE盒模型计算方式： 1总宽度 = margin-left + width + margin-right 即W3C的盒模型中content不包括padding,border和margin，IE盒模型的content包括padding和border，不包括margin. 关于IE的版本IE5.5及更早的版本使用的是IE盒模型。很多人似乎没注意到IE6及更新的版本在标准兼容模式（standards compliant mode）下使用的是W3C的盒模型标准。我们说这是一个好消息因为这意味着此盒模型问题只会出现在IE5.5及其更早的版本中。只要为文档设置一个DOCTYPE，就会使得IE遵循标准兼容模式的方式工作。但是你如果非要用IE盒模型，CSS3提供了可能，可通过box-sizing:border-box指定。 参考：IE浏览器和CSS盒模型","categories":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://arthas.com.cn/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}]},{"title":"CSS之选择器","slug":"CSS之选择器","date":"2018-03-14T06:14:55.000Z","updated":"2018-03-14T06:18:20.228Z","comments":true,"path":"2018/03/14/CSS之选择器/","link":"","permalink":"http://arthas.com.cn/2018/03/14/CSS之选择器/","excerpt":"","text":"CSS选择器 伪类选择器 :link :visited –链接伪类，只能应用于锚元素 :hover :active :focus –动态伪类，理论上可以引用于任何元素 通用选择器 ：* {} 子选择器和相邻选择器(#nav&gt;li) 属性选择器：acronym[title](具有title属性的acronym元素)，还可以根据属性值应用样式a[rel=&quot;nofollow&quot;] ID选择器 类选择器 CSS选择器的优先级!important &gt; id &gt; class &gt; tag 权重 基本上，用style属性编写的规则总是比其他任何规则特殊，具有ID选择器的规则比没有ID选择器的规则特殊，具有类选择器的规则比只有类选择器的规则特殊。如果两个规则的特殊性相同，那么后定义的规则优先。 CSS定义的权重 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值： 1234567891011121314151617/*权重为1*/div&#123;&#125;/*权重为10*/.class1&#123;&#125;/*权重为100*/#id1&#123;&#125;/*权重为100+1=101*/#id1 div&#123;&#125;/*权重为10+1=11*/.class1 div&#123;&#125;/*权重为10+10+1=21*/.class1 .class2 div&#123;&#125; 应用样式1、链接样式 1&lt;link href=\"/css/basic.css\" ref=\"stylesheet\" type=\"text/css /&gt; 2、导入样式 1@import url(/css/advanced.css) 注意：导入样式表比链接样式表要慢","categories":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://arthas.com.cn/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}]},{"title":"前端常见问题解答总结","slug":"前端常见问题解答总结","date":"2018-03-14T03:20:37.000Z","updated":"2018-03-14T06:23:34.083Z","comments":true,"path":"2018/03/14/前端常见问题解答总结/","link":"","permalink":"http://arthas.com.cn/2018/03/14/前端常见问题解答总结/","excerpt":"","text":"1、前端性能优化常用的方法 通过CSS Sprites减少http请求次数，JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，增加静态资源服务器。 避免在页面的主体布局中使用table table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。 使用缓存技术 2、常见的http状态码 状态码 说明 200 服务器已成功处理了请求 301 请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL 302 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的 304 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容 403 服务器拒绝访问，资源不可用 404 请求的资源不存在 500 服务器内部错误 502 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答 3、一个div的居中问题水平居中 12345div &#123; width: 200px; height: 200px; margin: 0 auto;&#125; 垂直居中 以下均可以实现水平居中的同时垂直居中 1234567891011div &#123; width: 200px; height: 200px; border: 1px solid red; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto;&#125; 12345678910div &#123; width: 200px; height: 200px; border: 1px solid red; position: absolute; left: 50%; top: 50%; margin-top: -100px; margin-left: -100px;&#125; 对div中的元素水平垂直居中 123&lt;div&gt; &lt;p&gt;hello&lt;/p&gt;&lt;/div&gt; 12345678div &#123; width: 200px; height: 200px; border: 1px solid red; display: flex; align-items:center; justify-content:center;&#125; 或者 12345678910div &#123; width: 200px; height: 200px; border: 1px solid red; display: flex;&#125;div p &#123; margin: auto;&#125; 4、外边距叠加当两个或者更多垂直外边距相遇时，它们将形成一个外边距，这个外边距的高等于两个发生叠加的外边距的高度中的较大者 当一个元素包含在另一个元素中时，它们的顶和/或底外边距也会发生叠加 外边距可以与可以与本身叠加（空元素，有外边距，但没有边框和内边距，顶外边距与底外边距就碰到一起了，它们会发生叠加） 只有普通文档流中块框的垂直外边距才会发生外边距叠加。行内框，浮动框或者绝对定位框之间的外边距不会叠加 浮动常见的清除浮动的方法 在最后面增加一个元素，并且对其添加加clear:both属性 父元素增加overflow:hidden属性 伪元素:after添加clear:both属性","categories":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}],"tags":[{"name":"问题","slug":"问题","permalink":"http://arthas.com.cn/tags/问题/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}]},{"title":"JavaScript的类和模块","slug":"JavaScript的类和模块","date":"2018-03-07T07:05:30.000Z","updated":"2018-03-13T06:21:28.331Z","comments":true,"path":"2018/03/07/JavaScript的类和模块/","link":"","permalink":"http://arthas.com.cn/2018/03/07/JavaScript的类和模块/","excerpt":"","text":"JavaScript中类的一个重要特性是“动态可继承”。在JavaScript中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例。 1、constructor任何JavaScript函数都可以用作构造函数，并且调用构造函数是需要用到一个prototype属性的。因此，每个JavaScript函数(ECMAScript5中的Function.bind()方法返回的函数除外)都自动拥有一个prototype属性。这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性constructor。constructor的属性的值是一个函数对象： 1234567var F = function() &#123;&#125;var P = F.prototype;var c = P.constructor;c === F; 这意味着对象通常继承的constructor均指代它们的构造函数。由于构造函数是类的“公共标识”，因此这个constructor属性为对象提供了类。 2、类的扩充JavaScript中基于原型的继承机制是动态的：对象从其原型继承属性，如果创建对象之后原型的属性发生改变，也会影响到继承这个原型的所有实例对象。这意味着我们可以通过给原型对象添加新方法来扩充类。 构造函数是类的公共标识，但原型是唯一标识，尽管instanceof的右操作符是构造函数，但计算过程实际上是监测了对象的继承关系，而不是监测创建对象的构造函数。 3、JavaScript中的面向对象技术","categories":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://arthas.com.cn/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}]},{"title":"JavaScript面向对象","slug":"JavaScript面向对象","date":"2018-03-06T03:46:17.000Z","updated":"2018-03-13T06:21:42.899Z","comments":true,"path":"2018/03/06/JavaScript面向对象/","link":"","permalink":"http://arthas.com.cn/2018/03/06/JavaScript面向对象/","excerpt":"","text":"对象是JavaScript的基本数据类型，可以通过对象直接量、关键字new和（ECMAScript 5中的）Object.create()函数来创建对象。JavaScript对象可以从一个称为原型的对象继承属性，这种“原型式继承”是JavaScript的核心特征，JavaScript对象都是关联数组。 对象的属性具有一些属性特性 可写（writable attribute） 表明是否可以设置该属性的值 可枚举（enumerable attribute） 表明是否可以通过for/in循环返回该值 可配置 （configureable attribute） 表明是否可以删除或者修改该属性 1、创建对象1、创建对象最简单的方式是使用对象直接量。直接量是有若干名/值对组成的映射表。 1var point = &#123;x: 12, y: 30&#125;; 所有通过对象直接量创建的对象，都具有同一个原型对象，并可以通过Object.prototype获得对原型对象的引用。 2、通过new关键字创建 1var obj = new Object(); 通过关键字new和构造函数创建的对象，原型就是构造函数的prototype属性。故通过{}创建的对象和通过new Object()创建的对象原型相同。 3、Object.create() ECMAScript5定义了Object.create()方法，它创建一个新对象，其中第一个参数是这个对象的原型，第二个参数可选，用以对对象的属性进行进一步描述。 可以通过传入参数null来创建一个没有原型的对象，但以这种方式创建的对象不会继承任何东西。 入股偶需要创建一个普通的空对象（比如通过{}或者new Object()创建的对象），需要传入Object.prototype 1var obj = Object.create(Object.prototype); // 和&#123;&#125;、`new Object()`一样 可以通过任意原型创建新对象，（换句话说，可以使任意对象继承），这是一个强大的特性。 2、原型每一个JavaScript对象(null除外)都是从原型继承属性。 3、继承假设要查询对象o的属性x，如果o中不存在x，那么将会继续在o的原型对象中查询属性x，如果原型对象中也没有x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x或者查找到一个原型是null的对象为止。可以看到，对象的原型属性构成了一个“链”，通过这个链可以实现属性的继承。只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关。 4、属性访问错误两种避免属性访问错误的写法： 12345678// 冗余但易懂var len = underfined;if (book) &#123; if (book.subtitle) len = book.subtitle.length;&#125;// 更简练var len = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length; 5、删除属性delete属性只能删除自有属性，不能删除继承属性，也不能删除那些可配置属性我false的属性。 6、监测属性可以通过in运算符，hasOwnProperty()和propertyIsEnumerable()判断某个属性是否存在某个对象中。 in 自由属性和继承属性能找到都返回true； hasOwnProperty() 只能找出自由属性； propertyIsEnumerable() 只能找出自有属性且这个属性可枚举性为true的属性 7、枚举属性除了监测对象是否存在，还需有遍历对象的所有属性。 for/in循环可以遍历对象的所有可枚举属性（包括自由属性和可枚举属性）。对象继承的内置方法不可枚举，但在代码中给对象添加的属性都是可枚举的（除非转换成不可枚举的）。 Object.keys()返回一个数组，这个数组由对象中可枚举的自有属性的名称组成（原理与下面的工具keys类似）。 Object.getOwnPropertyNames() 与Object.keys()类似，不过返回的不仅仅是可枚举的自由属性，而是会返回对象的所有自有属性的名称。 以下是一些遍历的工具函数 1234567891011121314151617181920212223242526272829303132333435363738/** * 把p中可枚举的属性复制到o，并返回o * 如果p和o含有同名属性，则覆盖o中的属性 * 这个函数并不处理getter和setter以及复制属性 */function extend(o, p) &#123; for (prop in p) &#123; o[propk] = p[prop]; &#125; return o;&#125;/** * 把p中可枚举的属性复制到o，并返回o * 如果p和o含有同名属性，则o不受影响 * 这个函数并不处理getter和setter以及复制属性 */function merge(o, p) &#123; for (prop in p) &#123; if (o.hasOwnProperty[prop]) continue; o[prop] = p[prop]; &#125; return o;&#125;/** * 返回一个数组，包含o中可枚举的自由属性的名字(key) */function keys(o) &#123; if (typeof o !== 'object') throw TypeError(); var result = []; for (var prop in o) &#123; if (o.hasOwnProperty[prop]) &#123; result.push(prop); &#125; &#125; return result;&#125; 8、属性getter和setter在ECMAScript5中，属性值可以用一个或两个方法代替，这两个方法就是getter和setter。由getter，setter定义的属性称为“存储器属性”。它不同于“数据属性”，数据属性只是一个简单的值。 当程序查询存取器属性的值时，JavaScript调用getter方法，这个方法的返回值就是属性存储器表达式的值。当程序设置一个存储器属性的值时，JavaScript调用setter方法，j将赋值表达式右侧的值作为参数传入setter，从某种意义上讲，这个方法负责设置属性的值。 123456789101112var obj = &#123;&#125;;obj = &#123; name: 'zhang', get allName () &#123; console.log('get'); return this.name; &#125;, set allName (value) &#123; console.log('set'); this.name = value; &#125; &#125; 和数据属性一样，存储器属性也是可以继承的。 9、属性的特性数据属性的4个特性为： value 值 writable 可写性 enumerable 可枚举性 configuable 可配置性 存储器属性的两个特性： get 可读性 set 可写性 enumerable 可枚举性 configuable 可配置性 为了实现属性特性的查询和设置操作，ECMAScript5定义了一个“属性描述符”的对象，这个对象代表那四个特性，描述符对象的特性和它们所描述的属性特性同名。Object.getOwnPropertyDescriptor可以获得某个对象特定属性的属性描述符。 12Object.getOwnPropertyDescriptor(&#123;x: 1&#125;, 'x'); // &#123;value: 1, writable: true, enumerable: true, configurable: true&#125; 要想设置属性的特性，或者想让新建属性具有某种特性，则需要调用Object.defineProperty()，这个方法要么修改已有属性，要么新建自由属性，但不能修改继承属性。 12345678910111213141516// 数据属性Object.defineProperty(obj, 'name', &#123; value: 'wang', writable: true, enumerable: true, configurable: true&#125;) // 存储器属性Object.defineProperty(obj, 'name', &#123; get: functon() &#123; return 'wang'; &#125;, set: function() &#123; &#125; &#125;) 如果要同时修改或者创建多个属性，就需要用Object.defineProperties(); 10、对象的三个属性 原型属性 原型属性是用来继承属性的,ECMAScript5中通过Object.getPrototypeOf()可以查看对象的原型。通过对象直接量或者Object.create()创建的对象包含一个名为constructor的属性，这个属性代指Object()构造函数。因此，constructor.prototype才是对象直接量的真正原型，但对于通过Object.create()创建的对象则往往不是这样的。监测一个对象是否是另一个对象的原型，可以用isPrototypeOf来监测。 Mozilla实现的JavaScript对外暴露了一个专门命名为proto的属性，用以直接查询/设置对象的原型。但并不推荐使用proto，因为尽管Safari和Chrome的当前版本都支持它，但IE和Opera还未实现它（可能以后也不会实现）。实现了ECMAScript5的Firefox版本依然支持proto，但对修改不可扩展对象的原型做了限制。 类属性 对象的类属性是一个字符串，用以白哦是对象的类型信息。 可扩展性 对象的可扩展性用以表示是否可以给对象添加新属性。所有内置对象和自定义对象都是显式可扩展的。","categories":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://arthas.com.cn/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}]},{"title":"UML类图教程","slug":"UML类图教程","date":"2018-01-18T15:30:07.000Z","updated":"2018-03-13T06:06:57.000Z","comments":true,"path":"2018/01/18/UML类图教程/","link":"","permalink":"http://arthas.com.cn/2018/01/18/UML类图教程/","excerpt":"","text":"矩形框代表一个类，类图分三层，第一层显示类名称，如果是抽象类，用斜体显示，第二层是类的特性，通常是字段和属性。第三层是类的操作，通常是方法或行为。前面的符号‘+’表示public，‘-’表示private，‘#’表示protected。 一、简介UML类图中存在着六大关系：关联(association)、聚合(aggregation)、组合(composition)、依赖(dependency)、泛化(generalization)/继承(inheritance)和实现(realization)，分别用如下图示表示： (关联)Association：A类有B类有逻辑上的连接(当一个类知道另一个类时使用关联) (聚合)Aggregation : A类有一个B类 (组合)Composition : A类拥有一个B类 (依赖)Dependency : A类使用了B类 (继承)Inheritance : B类是一个A类 (或者B类扩展A类) (实现)Realization : B类实现了接口A 二、关联(association) 关联描述两个类之间行为的一般二元关系。例如，一个学生选修一门特定的课程是学生类Student和课程类Course之间的一个关联，而一个教师教授一门课程是师资类Faculty和课程类Course之间的一个关联。Java代码中，关联可以用属性和方法来实现。 12345678910111213141516171819202122232425262728public class Student &#123; private Course[] courses; public void addCourse(Course s) &#123; . . . . . . &#125;&#125;public class Course &#123; private Strudent[] students; private Faculty faculty; public void addStudent(Student s) &#123; . . . . . . &#125; public void setFaculty(Faculty faculty) &#123; this.faculty = faculty; &#125;&#125;public class Faculty &#123; private Course[] courses; public void addCourse(Course s) &#123; . . . . . . &#125; &#125; 三、聚合(Aggregation) 聚合是一种特殊的关联(Association)形式，表示两个对象之间的所属(has-a)关系。所有者对象称为聚合对象，它的类称为聚合类；从属对象称为被聚合对象，它的类称为被聚合类。例如，一个公司有很多员工就是公司类Company和员工类Employee之间的一种聚合关系。被聚合对象和聚合对象有着各自的生命周期，即如果公司倒闭并不影响员工的存在。 1234567public class Company &#123; private List&lt;Employee&gt; employees;&#125;public class Employee &#123; private String name; &#125; 四、组合(Composition) 聚合是一种较弱形式的对象包含(一个对象包含另一个对象)关系。较强形式是组合(Composition). 在组合关系中包含对象负责被包含对象的创建以及生命周期，即当包含对象被销毁时被包含对象也会不复存在。例如一辆汽车拥有一个引擎是汽车类Car与引擎类Engine的组合关系。下面是组合的一些例子。 (1)通过成员变量初始化 1234567public class Car &#123; private final Engine engine = new Engine(); &#125;class Engine &#123; private String type;&#125; (2)通过构造函数初始化 1234567891011public class Car &#123; private final Engine engine; public Car()&#123; engine = new Engine(); &#125;&#125;public class Engine &#123; private String type;&#125; (3)通过延迟初始化 12345678910111213public class Car &#123; private final Engine engine; public Engine getEngine() &#123; if (null == engine) &#123; engine = new Engine(); &#125; return engine; &#125; &#125;public class Engine &#123; private String type;&#125; 五、依赖(Dependency) 依赖(Dependency)描述的是一个类的引用用作另一个类的方法的参数。例如，可以使用Calendar类中的setTime(Date date)方法设置日历，所以Calendar和Date之间的关系可以用依赖描述。 12345678public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; &#123; public final void setTime(Date date) &#123; setTimeInMillis(date.getTime()); &#125; . . . . . .&#125; 在依赖关系中，类之间是松耦合的。 六、继承(Inheritance) 继承(Inheritance)模拟两个类之间的is-a关系。强是(strong is-a)关系描述两个类之间的直接继承关系。弱是(weak is-a)关系描述一个类具有某个属性。强是关系可以用类的继承表示。例如，Spring的ApplicationEvent是一个EventObject，ApplicationEvent和EventObject间就是一种强是关系，可以用继承描述 123public abstract class ApplicationEvent extends EventObject &#123; . . . . . .&#125; 七、实现(Realization) 实现(Realization)描述的是一个类实现了接口（可以是多个）。上面描述的弱是(weak is-a)关系就可以用接口表示。例如字符串是可以被序列化的，这就可以用实现来描述。 123public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; . . . . . .&#125; 八、参考资料UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现 UML类图关系（泛化 、继承、实现、依赖、关联、聚合、组合）","categories":[{"name":"设计","slug":"设计","permalink":"http://arthas.com.cn/categories/设计/"}],"tags":[{"name":"UML","slug":"UML","permalink":"http://arthas.com.cn/tags/UML/"}],"keywords":[{"name":"设计","slug":"设计","permalink":"http://arthas.com.cn/categories/设计/"}]},{"title":"JavaScript之Event对象","slug":"JavaScript之Event对象","date":"2018-01-15T12:38:06.000Z","updated":"2018-03-13T06:21:59.637Z","comments":true,"path":"2018/01/15/JavaScript之Event对象/","link":"","permalink":"http://arthas.com.cn/2018/01/15/JavaScript之Event对象/","excerpt":"","text":"Event接口表示在DOM中发生的任何事件; 一些是用户生成的（例如鼠标或键盘事件），而其他由API生成(例如指示动画已经完成运行的事件，视频已被暂停等等)。有许多类型的事件，其中一些使用基于主要事件接口的其他接口。事件本身包含所有事件通用的属性和方法。 注册事件监听器有三种方式可以为DOM元素注册事件处理函数。(// Assuming myButton is a button element) EventTarget.addEventListener myButton.addEventListener(‘click’, function(){alert(‘Hello world’);}, false); HTML 属性 &lt;button onclick=&quot;alert(&#39;Hello world!&#39;)&quot;&gt; DOM 元素属性 myButton.onclick = function(event){alert(‘Hello world’);}; DOM Event 接口属性 Event.bubbles 只读 一个布尔值，用来表示该事件是否在DOM中冒泡。 …… 方法 event.initEvent 通过DocumentEvent的接口给被创建的事件初始化某些值。 event.preventDefault 取消事件（如果该事件可取消）。 event.stopPropagation 停止事件冒泡","categories":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://arthas.com.cn/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}]},{"title":"佳能相机使用指南","slug":"佳能相机使用指南","date":"2017-12-10T03:10:46.000Z","updated":"2018-02-13T12:17:28.000Z","comments":false,"path":"2017/12/10/佳能相机使用指南/","link":"","permalink":"http://arthas.com.cn/2017/12/10/佳能相机使用指南/","excerpt":"基本概念测光模式: 评价测光 局部测光 点测光 中央重点测光 光线均匀的时候用评价测光;背光比较严重，发差比较大的时候用局部测光或者点测光;人物放在中间的时候用中央重点测光; 白平衡: 用来控制相机的色彩还原，因为物体受到了环境色的影响 自动对焦:ONE SHOT AI FOCUS AI SERVO ONE SHOT 单次对焦，用于拍摄运动幅度不大的物体，比如静物 AI FOCUS 用于拍摄无法预知的物体，比如小孩 AI SERVO 连续对焦 用于拍摄连续运动的物体，比如运动的车 注：只要运动幅度不大，尽量使用单次对焦","text":"基本概念测光模式: 评价测光 局部测光 点测光 中央重点测光 光线均匀的时候用评价测光;背光比较严重，发差比较大的时候用局部测光或者点测光;人物放在中间的时候用中央重点测光; 白平衡: 用来控制相机的色彩还原，因为物体受到了环境色的影响 自动对焦:ONE SHOT AI FOCUS AI SERVO ONE SHOT 单次对焦，用于拍摄运动幅度不大的物体，比如静物 AI FOCUS 用于拍摄无法预知的物体，比如小孩 AI SERVO 连续对焦 用于拍摄连续运动的物体，比如运动的车 注：只要运动幅度不大，尽量使用单次对焦 ISO 天气晴朗的室外，100-400 阴天或傍晚 400-1600 黑暗的室内或者夜晚 1600-6400.H（H表示扩展ISO） 原则：只要光线允许，都应该让ISO的值越低，高了就会有噪点 闪光补偿:用来配合闪光灯使用，闪光灯打过了，给负补偿，闪光灯不足，给正补偿在目镜中观察标尺，左边表示光线不足，右边表示光线过大 历史小孔成像 机身和镜头的详细介绍卡口环 快门键 热靴 取景器 肩屏 脚架螺口（通用） 电池仓 镜头 焦距: 焦距越长，镜头的视角越窄；焦距越短，镜头的视角越宽 以焦距为标准的镜头分类 按聚焦局是否可变：变焦镜头、定焦镜头 按焦距长短：广角、标准、中焦、长焦 按特殊用途：微距镜头、移轴镜头 广角：全幅28mm焦距 非全幅28mm/1.6 标准：全幅50mm焦距 非全幅50mm/1.6 中焦：全幅85mm-135mm 非全幅=全幅/1.6 长焦：全幅135mm焦距 非全幅135mm/1.6 靠的近：会变形，尴尬，无法对焦 自动对焦: 非常暗的地方，没有层次的物体，透过玻璃拍 这些情况需要用手动对焦 四、快门、光圈与各种曝光模式光圈光圈是一个用来控制光线透过镜头，进入机身内感光面的光亮的装置，它在镜头内。光圈的值越大，进光越小；光圈的值越小，进光越大； 1:3.5-5.6 非恒定光圈焦距为18的时候，光圈能达到3.5；焦距为135的时候，光圈为5.6变焦的过程中光圈会改变景深：画面中纵向上静物清晰的范围光圈越大，景深越小；光圈越小，景深越大。通过大光圈拍摄小景深照片，背景很模糊的照片，净化构图。 快门与光圈的成级变化：T：1/2 1/4 1/8 1/15 1/30 1/60 1/125 1/250 ……F: 1 1.4 2 2.8 4 5.6 8 11 16 22……..快门通过控制进光时间控制进光量快门可以决定画面的亮度快门速度越高，画面越清晰；快门速度越低，画面越模糊高速快门拍瞬间，低速快门记录轨迹 拨盘AV 光圈优先模式光圈值手动，快门相机定 光圈先决直接影响到景深的大小拍人用大光圈，如F2.7 F2.8 ,拍摄风景可以用小光圈，如F11 F12光圈值大于8时可以叫小光圈 TV 快门优先模式高速运动的物体使用高速的快门拍摄一个不动的人，一般1/60s就可以拍摄一个缓步行走的人1/125s拍摄一个跑动的人1/250s拍摄一辆行驶的汽车1/400s1s能把水流拍摄的像绸缎一样 当快门开到很高时，如果出现光圈值闪烁，说明即使把光圈值开到最大，也无法正常曝光，此时需要降低快门速度以获得正确曝光。 曝光补偿：拍摄黑色物体时可以给一点负的曝光补偿，拍摄白色物体时可以给点正的曝光补偿 五、像素、白平衡、相对感光度P档下可以自由设置参数，A档（傻瓜档）无法设置 画幅1、画幅越大，能够实现的像素值越高2、同等条件下，画幅大的影像品质高3、画幅越大，广角优势越明显 注：数码相机可以更改像素，但并非缩小画幅。 感光度提速快门，抓拍运动的物体只要光线允许，尽量使用低的ISO，多用脚架，ISO只是手持的时候辅助曝光。 白平衡数码相机专有的功能固有色还原，条件色还原任何情况下，使用日光灯，条件色的还原 拍摄晚霞的时候，使用“阴天”会让晚霞更红，因为阴天有一部分蓝色，相机为了中和蓝色，会多用一下黄色暖光中和，导致画面更红。 夜景，色温值设的越低，相机会做冷色补偿，画面偏蓝色 色温值设的越高，相机会做暖调的补偿，画面偏红 六、景深原理与对焦景深的三要素 1、景深与光圈成反比2、景深与焦距成反比3、景深与拍摄距离（对焦距离）成正比 焦点的选择七、曝光补偿与手动模式M档曝光补偿将失效M档设置参数时参考内置的游标，箭头在左表示曝光不足，此时当放慢快门，放大光圈，或者增加ISO；箭头在右表示曝光过度此时当增加快门，缩小光圈，或者减小ISO; 中间灰 白加黑减中间灰色不补充*键锁定曝光 八、测光模式测光模式的选择1、评价测光 也叫平均测光，适用于受光均匀的场景。 2、局部测光3、 点测光适用于反差很大的场景，是非常极端的测光方式，只测算焦点附近的区域，如逆光拍摄， 剪影等 只测量5%-15%佳能相机取取景器中心的点测光，当焦点不在取景器中心时，使用*键（曝光锁定键）先锁定曝光，然后再对焦4、中央重点测光适用于稍微有点反差，偏重于画面中心的位置，兼顾周围环境 九、夜景摄影与夜景人像摄影相机配置：宜广角镜头、配三脚架机身设置：1、一般使用低的ISO控制画面的细腻度，并实现长时间曝光；2、阳光模式还原条件色、高温色呈现暖调、低色温表现冷调；3、单次对焦、如失效使用手动对焦；4、平均测光（评价测光、3D矩阵测光，加权测光……）；5、小光圈实现慢快门并将光圈表现出星芒、大光圈拍摄局部特写，营造虚化背景的梦幻效果；6、按测光表反馈获得，根据画面亮度做补偿；7、三脚架、快门线、中灰滤镜、黑卡纸。 注意：打开相机的“长时间曝光进行降噪”功能； 夜景摄影没有苛刻的曝光要求，自己决定； 避开大功率光源； 入夜是拍摄夜景的最佳时机； 当把相机架在三脚架上后一定要关闭防抖，否则会适得其反； 人像摄影快门优先 1、稍高的ISO（如400-800），稍大的光圈（如F4，F2.8）拍摄夜景，找出合适的快门，在此快门基础上减少一到两级曝光；2、WB设置闪光灯模式；3、以人物对焦；4、开启闪光灯，设置后帘同步；5、试拍摄，按照画面亮度做出闪光补偿；","categories":[{"name":"摄影","slug":"摄影","permalink":"http://arthas.com.cn/categories/摄影/"}],"tags":[{"name":"单反","slug":"单反","permalink":"http://arthas.com.cn/tags/单反/"}],"keywords":[{"name":"摄影","slug":"摄影","permalink":"http://arthas.com.cn/categories/摄影/"}]},{"title":"Algorithms中的复杂度","slug":"Algorithms中的复杂度","date":"2017-12-06T06:55:21.000Z","updated":"2018-03-15T02:33:31.234Z","comments":true,"path":"2017/12/06/Algorithms中的复杂度/","link":"","permalink":"http://arthas.com.cn/2017/12/06/Algorithms中的复杂度/","excerpt":"1、一个时间复杂度的问题有一个字符串数组，将数组中的每一个字符串按照字母序排序，之后再将整个字符串数组按照字典序排序，求整个操作的时间复杂度。 假设最长的字符串长度为s，数组中有n个字符串对每个字符串排序：O(slogs)将数组中每一个字符串按照字母序排序：O(nslog(s))将整个字符串数组按照字典序排序：O(snlog(n)) (因为字符串长度为s)所以，整个操作的时间复杂度为： O(n*slog(s)) + O(s*nlog(n)) = O(n*s(logs+logn))","text":"1、一个时间复杂度的问题有一个字符串数组，将数组中的每一个字符串按照字母序排序，之后再将整个字符串数组按照字典序排序，求整个操作的时间复杂度。 假设最长的字符串长度为s，数组中有n个字符串对每个字符串排序：O(slogs)将数组中每一个字符串按照字母序排序：O(nslog(s))将整个字符串数组按照字典序排序：O(snlog(n)) (因为字符串长度为s)所以，整个操作的时间复杂度为： O(n*slog(s)) + O(s*nlog(n)) = O(n*s(logs+logn)) 2、常见算法复杂度：二分查找法：O(logn)寻找数组中的最大值/最小值：O(n)归并排序算法：O(nlogn)选择排序法：O(n^2) 3、算法复杂度在有些情况下是与用例相关的 场景 插入排序算法O(n^2) 快速排序算法O(nlog(n)) 最差情况 O(n^2) O(n^2) 最好情况 O(n) O(nlog(n)) 平均情况 O(n^2) O(nlog(n)) 4、数据规模的概念如果想要在1s内解决问题：O(n^2)的算法可以处理大约10^4(万)级别的数据O(n)的算法可以处理大约10^8(千万)级别的数据O(nlog(n))的算法可以处理大约10^7(百万)级别的数据 5、空间复杂度递归的调用是有空间代价的空间复杂度O(1) 12345678int sum1 (int n) &#123; assert(n &gt;= 0); int ret = 0; for (int i = 0; i &lt;= n; i++) &#123; ret += i; &#125; return ret;&#125; 空间复杂度为O(n)1234567int sum2 () &#123; assert(n &gt;= 0); if (n === 0) &#123; return 0; &#125; return n + sum2(n-1);&#125; 求以下算法的时间复杂度 12345678public void sayHelloWorld() &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 30; j++) &#123; System.out.println(\"hello world\"); &#125; &#125;&#125;// O(n) 二分查找法的时间复杂度：O(logn)","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://arthas.com.cn/categories/编程基础/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://arthas.com.cn/tags/Algorithms/"}],"keywords":[{"name":"编程基础","slug":"编程基础","permalink":"http://arthas.com.cn/categories/编程基础/"}]},{"title":"掌握正则表达式","slug":"掌握正则表达式","date":"2017-12-06T06:55:21.000Z","updated":"2018-03-23T02:05:13.767Z","comments":true,"path":"2017/12/06/掌握正则表达式/","link":"","permalink":"http://arthas.com.cn/2017/12/06/掌握正则表达式/","excerpt":"","text":"正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法。本章介绍 JavaScript正则表达式。 预定义字符正则表达式为我们提供了几个常用的预定义类来匹配常见的字符,任何预定义字符么有加上数量词之前都只能匹配一个字符。 字符 等价类 含义 . [^\\n\\r] 除了回车符和换行符之外的所有字符 \\d [0-9] 数字字符 \\D [^0-9] 非数字字符 \\s [ \\t\\n\\x0B\\f\\r] 空白符 \\S [^ \\t\\n\\x0B\\f\\r] 非空白符 \\w [a-zA-Z_0-9] 单词字符(字母、数字、下划线) \\W [^a-zA-Z_0-9] 非单词字符 1eg: ab+数字+任意字符 --- ab\\d. 边界正则表达式还提供了几个常用的边界匹配字符 字符 含义 ^ 以xx开头 $ 以xx结尾 \\b 单词边界，指[a-zA-Z_0-9]之外的字符 \\B 非单词边界 量词 字符 含义 ？ 出现零次或一次（最多出现一次） + 出现一次或多次（至少出现一次） * 出现零次或多次（任意次） {n} 出现n次 {n, m} 出现n到m次 {n, } 至少出现n次 \\w+\\b Byron 匹配 单词＋边界＋Byron 12345(/\\w+\\b Byron/).test('Hi Byron'); //true(/\\w+\\b Byron/).test('Welcome Byron'); //true(/\\w+\\b Byron/).test('HiByron'); //false \\d+\\.\\d{1,3} 匹配三位小数的数字 贪婪模式与非贪婪模式看了上面介绍的量词，也许爱思考的同学会想到关于匹配原则的一些问题，比如{3,5}这个量词，要是在句子中出现了十次，那么他是每次匹配三个还是五个，反正3、4、5都满足3～5的条件，量词在默认下是尽可能多的匹配的，也就是大家常说的贪婪模式 1'123456789'.match(/\\d&#123;3,5&#125;/g); //[\"12345\", \"6789\"] 既然有贪婪模式，那么肯定会有非贪婪模式，让正则表达式尽可能少的匹配，也就是说一旦成功匹配不不再继续尝试，做法很简单，在量词后加上 ? 即可 1'123456789'.match(/\\d&#123;3,5&#125;?/g); //[\"123\", \"456\", \"789\"] 分组有时候我们希望使用量词的时候匹配多个字符，而不是像上面例子只是匹配一个，比如希望匹配Byron出现20次的字符串，我们如果写成 Byron{20} 的话匹配的是Byro＋n出现20次，怎么把Byron作为一个整体呢？使用()就可以达到次目的，我们称为分组 1(Byron)&#123;20&#125; 如果希望匹配Byron或Casper出现20次该怎么办呢？可以使用字符 ｜ 达到或的功效 1(Byron|Casper)&#123;20&#125; 我们看到图中有个＃1的东东，那是什么？使用分组的正则表达式会把匹配项也放到分组中，默认就是按数字编号分发的，各异根据编号获得捕获的分组内容，这个在一些希望具体操作第几个匹配项的函数中很有用 1(Byron).(ok) 如果有分组嵌套的情况，外面的组的编号靠前 1((^|%&gt;)[^\\t]*) 有时候我们不希望捕获某些分组，只需要在分组内加上 ?: 就可以了，着并不意味着该分组内容不属于正则表达式，只是不会给这个分组加编号了而已 1(?:Byron).(ok) 前瞻 表达式 含义 exp1(?=exp2) 匹配后面是exp2的exp1 exp1(?!exp2) 匹配后面不是exp2的exp1 举个例子： good(?=Byron) 123(/good(?=Byron)/).exec('goodByron123'); //['good'](/good(?=Byron)/).exec('goodCasper123'); //null(/bad(?=Byron)/).exec('goodCasper123');//null 通过上面例子可以看出 exp1(?=exp2) 表达式会匹配exp1表达式，但只有其后面内容是exp2的时候才会匹配，也就是两个条件，exp1(?!exp2) 比较类似 good(?!Byron) 123(/good(?!Byron)/).exec('goodByron123'); //null(/good(?!Byron)/).exec('goodCasper123'); //['good'](/bad(?!Byron)/).exec('goodCasper123');//null 参考资料 JavaScript 正则表达式上——基本语法 司徒正美 javascript正则表达式 https://regexper.com/ 15个常用的javaScript正则表达式","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://arthas.com.cn/categories/编程基础/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://arthas.com.cn/tags/正则/"}],"keywords":[{"name":"编程基础","slug":"编程基础","permalink":"http://arthas.com.cn/categories/编程基础/"}]},{"title":"Nginx反向代理实现Tomcat集群","slug":"Nginx反向代理实现Tomcat集群","date":"2017-01-17T04:52:22.000Z","updated":"2017-03-22T16:06:39.649Z","comments":true,"path":"2017/01/17/Nginx反向代理实现Tomcat集群/","link":"","permalink":"http://arthas.com.cn/2017/01/17/Nginx反向代理实现Tomcat集群/","excerpt":"对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。","text":"对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。 反向代理有两个作用： 保护和隐藏原始资源服务器 负载均衡 Nginx Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。 基本操作 双击nginx.exe启动（windows下） nginx -s stop关闭 nginx -s reload在不关闭nginx的情况下更新配置文件 搭建集群修改tomcat配置文件准备好需要搭建集群的tomcat，分别修改端口号以避免端口冲突。 进入tomcat*/conf/server.xml，修改如下信息： port修改成没有占用的:1&lt;Server port=&quot;8006&quot; shutdown=&quot;SHUTDOWN&quot;&gt; 修改port参数123&lt;Connector port=&quot;9999&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 修改port参数1&lt;Connector port=&quot;8010&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; 加入jvmRoute=&quot;tomcat*，值相当于给tomcat起了个名字，1&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcat*&quot;&gt; 修改完所有的tomcat参数，假设配置了两个tomcat，分别起名为tomcat1,tomcat2。 修改Nginx配置文件打开nginx配置文件nginx/conf/nginx.conf,123456789101112131415161718upstream server_lb&#123; server 127.0.0.1:8888 weight=10; //集群的地址和端口 server 127.0.0.1:9999 weight=5; //weight表示权重 &#125; server &#123; listen 80; server_name localhost; //网站域名 #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; proxy_pass http://server_lb; //实现反向代理 index index.html index.htm; &#125; session共享tomcat中session共享最简单的方法是修改tomcat的server.xml文件，去掉以下代码的注释，使其生效即可1&lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;/&gt;","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://arthas.com.cn/tags/Nginx/"}],"keywords":[]},{"title":"设备像素比的实际意义","slug":"设备像素比的实际意义","date":"2016-12-17T11:44:32.000Z","updated":"2017-09-02T01:48:50.538Z","comments":true,"path":"2016/12/17/设备像素比的实际意义/","link":"","permalink":"http://arthas.com.cn/2016/12/17/设备像素比的实际意义/","excerpt":"设备像素比devicePixelRatio简单介绍一文专业介绍了设备像素比，摘抄精简为以下：设备像素比（devicePixelRatio）其实指的是window.devicePixelRatio, 被所有WebKit浏览器以及Opera所支持，随着显示器的发展，这个属性也慢慢登上了前端技术的舞台。window.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。","text":"设备像素比devicePixelRatio简单介绍一文专业介绍了设备像素比，摘抄精简为以下：设备像素比（devicePixelRatio）其实指的是window.devicePixelRatio, 被所有WebKit浏览器以及Opera所支持，随着显示器的发展，这个属性也慢慢登上了前端技术的舞台。window.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。 1设备像素比 = 物理像素 / 设备独立像素 设备独立像素（这是Android中的叫法，就是web开发中CSS像素）与屏幕密度(硬件)有关。可以用来辅助区分视网膜设备还是非视网膜设备。所有非视网膜屏幕的iphone在垂直的时候，宽度为320物理像素，当你使用1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 的时候，会设置视窗布局宽度（不同于视觉区域宽度，不放大显示情况下，两者大小一致）为320px, 于是，页面很自然地覆盖在屏幕上。而对于视网膜屏幕的iphone，如iphone4s, 纵向显示的时候，屏幕物理像素640像素。同样，当用户设置1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 的时候，其视区宽度并不是640像素，而是320像素，这是为了有更好的阅读体验 – 更合适的文字大小。 这样，在视网膜屏幕的iphone上，屏幕物理像素640像素，独立像素还是320像素，因此，window.devicePixelRatio等于2 从以上现象得出的结论是：UI设计师按照手机物理像素出设计稿，切图时根据其设备像素比来换算设备独立像素（CSS像素），比如视网膜手机iPhone6，物理像素750px×1334px，由于其设备像素比为2，CSS切图时需要将设计稿的所有尺寸除以2，才是正确CSS像素值。","categories":[],"tags":[{"name":"dpr","slug":"dpr","permalink":"http://arthas.com.cn/tags/dpr/"}],"keywords":[]},{"title":"关于fiex的总结","slug":"关于flex的总结","date":"2016-11-28T01:41:43.000Z","updated":"2017-09-01T14:37:15.320Z","comments":true,"path":"2016/11/28/关于flex的总结/","link":"","permalink":"http://arthas.com.cn/2016/11/28/关于flex的总结/","excerpt":"","text":"Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器的属性 flex-directionflex-direction属性决定主轴的方向（即项目的排列方向） row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 justify-contentjustify-content属性定义了项目在主轴上的对齐方式。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-itemsalign-items属性定义项目在交叉轴上如何对齐。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性 orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrinkflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 实践案例flex自适应三列布局实现 参考资料：– 阮一峰 Flex 布局教程：语法篇","categories":[],"tags":[{"name":"flex","slug":"flex","permalink":"http://arthas.com.cn/tags/flex/"}],"keywords":[]},{"title":"windows下安装Sass的正确姿势","slug":"windows下安装Sass的正确姿势","date":"2016-11-22T07:56:19.000Z","updated":"2017-09-01T14:37:05.412Z","comments":true,"path":"2016/11/22/windows下安装Sass的正确姿势/","link":"","permalink":"http://arthas.com.cn/2016/11/22/windows下安装Sass的正确姿势/","excerpt":"","text":"安装网上流传到安装方式进行了安装，修改ruby源的时候报错123Error fetching https://gems.ruby-china.org/: SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed (https://gems.ruby-china.org/specs.4.8.gz) 当时一脸懵逼，后来反应过来是SSL证书的问题。只要把镜像的https改为http即可。 安装过程安装Ruby到Ruby官网下载ruby。一路确定，安装时记得对“加入到Path”打钩。 安装完控制台输入ruby -v出现版本号表示正确安装。 修改gem源以前可以用淘宝的源 https://ruby.taobao.org/,现在此源已经不维护，最新维护的源地址为https://gems.ruby-china.org/。修改方式：1234$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/$ gem sources -lhttps://gems.ruby-china.org# 确保只有 gems.ruby-china.org 如果遇到 SSL 证书问题，你又无法解决，请直接用 http://gems.ruby-china.org 避免 SSL 的问题。 安装Sass打开控制台，根据如下命令安装Sass1gem install sass 安装完输入sass -v表示正确安装。","categories":[],"tags":[{"name":"填坑","slug":"填坑","permalink":"http://arthas.com.cn/tags/填坑/"}],"keywords":[]},{"title":"mongodb速记","slug":"mongodb速记","date":"2016-11-19T04:39:32.000Z","updated":"2017-09-01T14:39:09.275Z","comments":true,"path":"2016/11/19/mongodb速记/","link":"","permalink":"http://arthas.com.cn/2016/11/19/mongodb速记/","excerpt":"在mongodb/bin下面运行启动指令，启动mongodb服务器要带数据文件的地址，比如：windows下： 1mongod.exe --dbpath &quot;f:\\mongodb\\data","text":"在mongodb/bin下面运行启动指令，启动mongodb服务器要带数据文件的地址，比如：windows下： 1mongod.exe --dbpath &quot;f:\\mongodb\\data linux下： 123mongod --dbpath=/data/db --port=27017 (只在控制台启动)mongod --dbpath=/data/db --port=27017 --fork --syslog (以守护进程的方式启动)mongod --shutdown (结束后台命令) 控制台连接mongodb服务器： 1mongo 127.0.0.1:27017 查看当前数据库 1show dbs 使用user数据库，可以是不存在的数据库 1use user 插入一条数据 1db.user.insert(&#123;&quot;username&quot;:&quot;zhangsan&quot;,&quot;password&quot;:&quot;apple&quot;&#125;) 查看所有数据 1db.user.find(); 查看指定条件的数据 1db.user.find(&#123;&quot;username&quot;:&quot;zhangsan&quot;&#125;); 查看一条数据 1db.user.findOne() 查看一条指定条件的数据 1db.user.findOne(&#123;&quot;username&quot;:&quot;zhangsan&quot;&#125;) 更新数据只更新一条 1db.users.update(&#123;&quot;username&quot;:&quot;mohong&quot;&#125;,&#123;$set: &#123;&quot;group&quot;:&quot;writer&quot;&#125;&#125;) 更新所有满足的值1db.users.update(&#123;&quot;username&quot;:&quot;mohong&quot;&#125;,&#123;$set: &#123;&quot;group&quot;:&quot;writer&quot;&#125;&#125;,&#123;multi:true&#125;); 删除文档 123db.users.remove() 删除db.users.remove(&#123;&quot;group&quot;:&quot;design&quot;&#125;) 删除满足条件的所有文档db.users.remove(&#123;&quot;group&quot;:&quot;design&quot;&#125;， true) 只删除集合中满足条件的第一个文档 删除集合 1db.users.drop() 参考资料The MongoDB 3.2 ManualGetting Started with MongoDB (MongoDB Shell Edition)","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://arthas.com.cn/tags/mongodb/"}],"keywords":[]},{"title":"初识ReactNative","slug":"初识ReactNative","date":"2016-11-17T07:27:30.000Z","updated":"2017-09-01T14:45:44.057Z","comments":true,"path":"2016/11/17/初识ReactNative/","link":"","permalink":"http://arthas.com.cn/2016/11/17/初识ReactNative/","excerpt":"开发环境的搭建思路是：Android开发+Node开发环境+git版本控制（可选）。入坑之前需要对这两者的开发有所了解，不然过程比较懵逼。比如Android开发环境就要配置Java开发环境，即安装JDK，配置环境变量，此处JDK版本需要jdk1.8。Node开发环境要安装node，配置环境变量时一定要通过新建ANDROID_HOME和JAVA_HOME系统变量的方式指定path，不然后面会出现找不到路径的报错.node自带npm包管理工具，跟java开发中的maven差不多。","text":"开发环境的搭建思路是：Android开发+Node开发环境+git版本控制（可选）。入坑之前需要对这两者的开发有所了解，不然过程比较懵逼。比如Android开发环境就要配置Java开发环境，即安装JDK，配置环境变量，此处JDK版本需要jdk1.8。Node开发环境要安装node，配置环境变量时一定要通过新建ANDROID_HOME和JAVA_HOME系统变量的方式指定path，不然后面会出现找不到路径的报错.node自带npm包管理工具，跟java开发中的maven差不多。 根据React Native 中文网文档第一篇配合AndroidDevTools依次安装工具。 安装完Android Studio后用其下载必须的包时尝试过AndroidDevTools上面的代理，不过好像没什么作用，需要科学上网才能下载。通过运行Android Studio检测一下Android开发环境。把Android SDK的tools和platform-tools目录添加到PATH变量中，以便在终端中运行一些Android工具。上图表示Android环境运行正常。可以放心开始node开发环境的测试。 在控制台运行node -v查看node是否安装成功，运行npm -v查看npm包管理器是否正常运行。下图表示两个都OK。然后在控制台运行npm install -g react-native-cli安装react-native命令行工具。 123react-native init myAppcd myAppreact-native run-android 也可以将app发送到真机上运行，真机运行查看在设备上运行。注意，如果您的设备是MIUI系统，可能运行会失败，控制台会有安装失败的报错。解决办法是把设置--跟多设置--开发者选项--启用MIUI这一项关闭。然后就OK了。","categories":[],"tags":[{"name":"react native","slug":"react-native","permalink":"http://arthas.com.cn/tags/react-native/"}],"keywords":[]},{"title":"javascript版2048开发总结","slug":"javascript版2048开发总结","date":"2016-10-13T12:33:13.000Z","updated":"2017-09-01T14:45:32.344Z","comments":true,"path":"2016/10/13/javascript版2048开发总结/","link":"","permalink":"http://arthas.com.cn/2016/10/13/javascript版2048开发总结/","excerpt":"","text":"2048这款游戏玩起来非常简单，但是又有着神奇的吸引力，尤其是对强迫症重症患者。所以界面的设计追求了简约、轻盈，清爽的原则，此游戏的色调已经成为经典，故小方格依然采用了经典色调。背景图片选择了可无缝拼接的木质材料，以达到全屏效果且优化了请求资源的大小，其暖色格调与小方格主色调搭配，使得界面更加柔和舒适，给小格子设置了0.9的不透明度，表现出清爽轻盈，使玩家玩游戏时心情更放松。 多端适配此游戏实现了手机、平板、PC三端完美适配。为了实现适配，采用了将样式的px单位改为rem的方法。 rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。 也就是说整个游戏中的样式，除了html的font-size以px为单位外，其他的单位均为相对于html的单位，只要html的单位大小改变，其他的尺寸成倍改变，且无损质量，无突变。这样只在js中写个判断设备的屏幕尺寸的函数，然后指定不同的屏幕html的font-size使用多少的px值就可以了。 布局结构html中的静态布局首先是一个大盒子下面放了16个小格子，大盒子相对定位，小盒子的样式均为绝对定位，这样16个小盒子就聚集在大盒子内部的左上角，接着在初始化过程中通过遍历动态指定这16个小盒子的top值和left值，此时浏览器中就出现了这样的局面。 同时再创建一个二维数组（javascript本来没有二维数组的概念，可以采取数组中包含数组的方式模拟）和上面的格子一一对应来保存格子中的数据，首先通过遍历均初始化为0。 接着再创建一个函数用来继续动态生成16个小格子，用来展示上面定义的二维数组中的数字和操作游戏，还是通过遍历来指定top和left和，上面的位置吻合。判断一下，当数组中的数字为0时，宽度和高度均为0，这样就看不到小格子了，顺便把位置设在小方格的正中央，这样后面有大于0的数字了展示出来效果好看。当数组中的数字不为0时，设置上面这个小方块的宽度、高度和下面的小格子的相同，达到了覆盖的效果，同时从颜色函数中选择此时数字对应的颜色，通过element.text显示数字，再用动画展示出来。如下图所示，O表示不显示的小方块。 移动操作分别针对上移、下移、左移、右移创建四个函数，将数字不为0的小方格移动到对应的位置。以左移函数为例，函数执行过程大概是，遍历所有小方格，如果有值不为0（此处的意思是，要能移动，必须要移动存在的看得见的小方格，无法移动不存在的物体，哲学。。。），再遍历其左边的位置，有两种情况，第一种是左边为0，通过动画函数把这个小方格移动到右边值为0的位置，依次遍历；第二种情况是左边不为0，但是它俩的值相等，那么就把右边的值加到左边，同时把右边位置的值设为0，通过动画函数展示出过程。同时把这个小方块的值加在分数上，更新分数。 返回功能创建一个全局数组，每一步的状态保存一个快照（对象），通过push（）存入数组，点击还原按钮的时候读取数组数据还原上一个状态。 遇到的问题及解决方案开发的过程并非一帆风顺。 背景图不能全屏显示刚开始背景图选择的模糊的田野公路的图片，通过给body设置背景图方式加入，但是在适配移动端的过程中发现不能完全匹配，在修改为重复的情况下依然有空白，于是换了更符合设计意图的无缝木质素材，且把指定背景图的元素由body改为html，解决了有空白的问题，更符合设计意图，优化了资源大小。 相等的数字在中间有格子的情况下会合并同一行的两个格子虽然数值相等但是中间有其他小方格的话是无法合并的，这个问题的出现是因为没有考虑到做这一判断，增加了判断障碍物的函数解决了问题。 返回上一步分数没有减少点击上一步按钮，场景回退到上一个状态，但是相应的分数却没有减少，于是想到分数也是当时场景的一部分，也应该保存下来，重新设计了保存状态的对象解决了问题。 开始新游戏后能回退到上一局如果游戏刚开始就多点几次开始新游戏创建新游戏，那么每次生成的游戏数据都会保存到数组中，这样点击返回上一步的时候就会返回到上一局的游戏状态。在给创建新游戏的函数中增加了清除保存游戏状态的数组的方法后到了正常状态。 小格子中的数字达到4位数的时候显示超出范围写小格子的样式的时候是指定统一的字体大小的，没有考虑到随着数字的增大，其所占的区域也在变大。在一次玩游戏的过程中终于达到1024，此时暴露出了这个问题，于是又增加了判断语句，当数字大于四位数时相应缩小。 回顾与反思rem的适配方式web app要使用rem这一相对单位作为单位，能等比例适配所有屏幕，而且是无损的，图片文字不会糊。使用时只需要通过js检测不同的屏幕尺寸设置不同的html的font-size值就可以了。 移动端触摸事件移动端要操作游戏，需要增加触摸事件touchstart：触摸开始的时候触发touchmove：手指在屏幕上滑动的时候触发touchend：触摸结束的时候触发 而每个触摸事件都包括了三个触摸列表，每个列表里包含了对应的一系列触摸点（用来实现多点触控）：touches：当前位于屏幕上的所有手指的列表。targetTouches：位于当前DOM元素上手指的列表。changedTouches：涉及当前事件手指的列表。 每个触摸点由包含了如下触摸信息（常用）：identifier：一个数值，唯一标识触摸会话（touch session）中的当前手指。一般为从0开始的流水号（android4.1，uc）target：DOM元素，是动作所针对的目标。 pageX/pageX/clientX/clientY/screenX/screenY：一个数值，动作在屏幕上发生的位置（page包含滚动距离,client不包含滚动距离，screen则以屏幕为基准）。 radiusX/radiusY/rotationAngle：画出大约相当于手指形状的椭圆形，分别为椭圆形的两个半径和旋转角度。初步测试浏览器不支持。 Gestures 这个事件针对IOS设备上的，一个Gestures事件在两个或更多手指触摸屏幕时触发。如果任何手指你正在监听的Gesture事件(gesturestart，gesturechange，gestureend)节点上，你将收到对应的gestures事件。 Gesturestart：当一个手指已经按在屏幕上，而另一个手指又触摸在屏幕时触发。 Gesturechange：当触摸屏幕的任何一个手指的位置发生改变的时候触发。 Gestureend：当任何一个手指从屏幕上面移开时触发。 1234// 判断是否为 iPhone ：function isAppleMobile() &#123; return (navigator.platform.indexOf(&apos;iPad&apos;) != -1);&#125;;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://arthas.com.cn/tags/javascript/"}],"keywords":[]},{"title":"定制自己的Bootstrap样式","slug":"定制自己的Bootstrap样式","date":"2016-09-26T10:25:15.000Z","updated":"2017-09-01T14:45:26.870Z","comments":true,"path":"2016/09/26/定制自己的Bootstrap样式/","link":"","permalink":"http://arthas.com.cn/2016/09/26/定制自己的Bootstrap样式/","excerpt":"本文主要针对对Bootstrap有所了解，或者使用过Bootstrap的读者提供参考。官方提供了个性化定制功能 ,可以选择自己需要的组件，插件，自己设置不同模块的less变量，最后从官网下载到一份编译后的个性化bootsrap。 如果是比较复杂的项目，虽然官网开放的变量上百个，但还是不能满足业务需求，这时候就需要下载源码修改less文件，bootstrap是通过less预编译的。","text":"本文主要针对对Bootstrap有所了解，或者使用过Bootstrap的读者提供参考。官方提供了个性化定制功能 ,可以选择自己需要的组件，插件，自己设置不同模块的less变量，最后从官网下载到一份编译后的个性化bootsrap。 如果是比较复杂的项目，虽然官网开放的变量上百个，但还是不能满足业务需求，这时候就需要下载源码修改less文件，bootstrap是通过less预编译的。 lessless是一种动态样式语言。LESS 将 CSS 赋予了动态语言的特性，如 变量， 继承， 运算， 函数.使用less可以这样写css： 123456789101112131415@base: #f938ab;.box-shadow(@style, @c) when (iscolor(@c)) &#123; box-shadow: @style @c; -webkit-box-shadow: @style @c; -moz-box-shadow: @style @c;&#125;.box-shadow(@style, @alpha: 50%) when (isnumber(@alpha)) &#123; .box-shadow(@style, rgba(0, 0, 0, @alpha));&#125;.box &#123; color: saturate(@base, 5%); border-color: lighten(@base, 30%); div &#123; .box-shadow(0 0 5px, 30%) &#125;&#125; less文件需要编译器才能转化为css文件。体验less编译可以在在线less编译器中编写less语句，然后编译成css文件。gulp使用gulp-less实现编译。 变量变量允许我们单独定义一系列通用的样式，然后在需要的时候去调用。所以在做全局样式调整的时候我们可能只需要修改几行代码就可以了。例如：12345678910 // LESS@color: #4D926F;#header &#123; color: @color;&#125;h2 &#123; color: @color;&#125; 编译之后的css文件：12345678/* 生成的 CSS */#header &#123; color: #4D926F;&#125;h2 &#123; color: #4D926F;&#125; 混合混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以带参数地调用，就像使用函数一样。1234567891011121314// LESS.rounded-corners (@radius: 5px) &#123; border-radius: @radius; -webkit-border-radius: @radius; -moz-border-radius: @radius;&#125;#header &#123; .rounded-corners;&#125;#footer &#123; .rounded-corners(10px);&#125; 编译后的css文件123456789101112* 生成的 CSS */#header &#123; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px;&#125;#footer &#123; border-radius: 10px; -webkit-border-radius: 10px; -moz-border-radius: 10px;&#125; 嵌套规则我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。12345678910111213// LESS#header &#123; h1 &#123; font-size: 26px; font-weight: bold; &#125; p &#123; font-size: 12px; a &#123; text-decoration: none; &amp;:hover &#123; border-width: 1px &#125; &#125; &#125;&#125; 编译后的css文件：123456789101112131415/* 生成的 CSS */#header h1 &#123; font-size: 26px; font-weight: bold;&#125;#header p &#123; font-size: 12px;&#125;#header p a &#123; text-decoration: none;&#125;#header p a:hover &#123; border-width: 1px;&#125; 函数 &amp; 运算运算提供了加，减，乘，除操作；我们可以做属性值和颜色的运算，这样就可以实现属性值之间的复杂关系。LESS中的函数一一映射了JavaScript代码，如果你愿意的话可以操作属性值。123456789101112131415// LESS@the-border: 1px;@base-color: #111;@red: #842210;#header &#123; color: @base-color * 3; border-left: @the-border; border-right: @the-border * 2;&#125;#footer &#123; color: @base-color + #003300; border-color: desaturate(@red, 10%);&#125; 编译后的css文件：1234567891011/* 生成的 CSS */#header &#123; color: #333; border-left: 1px; border-right: 2px;&#125;#footer &#123; color: #114411; border-color: #7d2717;&#125; bootstrap源码 Bootstrap 插件全部依赖 jQuery请注意，Bootstrap 的所有 JavaScript 插件都依赖 jQuery，因此 jQuery 必须在 Bootstrap 之前引入，就像在基本模版中所展示的一样。在 bower.json 文件中 列出了 Bootstrap 所支持的 jQuery 版本。 下载源码bootsrap源码托管于github，可以通过git命令克隆仓库：1git clone https://github.com/twbs/bootstrap.git 还可以通过包管理工具bower安装：1bower install bootsrap 运行次命令后，bower会下载最新版的bootsrap源码包到项目中。 源码解读Bootstrap 源码包含了预先编译的 CSS、JavaScript 和图标字体文件，并且还有 LESS、JavaScript 和文档的源码。具体来说，主要文件组织结构如下12345678910bootstrap/├── less/├── js/├── fonts/├── dist/│ ├── css/│ ├── js/│ └── fonts/└── docs/ └── examples/ less/、js/ 和 fonts/ 目录分别包含了 CSS、JS 和字体图标的源码。dist/ 目录包含了编译后的bootsrap的css文件。docs/ 包含了所有文档的源码文件，examples/ 目录是 Bootstrap 官方提供的实例工程。除了这些，其他文件还包含 Bootstrap 安装包的定义文件、许可证文件和编译脚本等。 bootstrap/less目录下的文件均为.less文件，是bootsrap样式的主要代码，不同的文件根据功能及性质命名。 bootstrap.less:这个是核心文件。它用来引入其他文件，最终由你来编译它。 reset.less:初始化文件，始终是最先引入的文件。 utilities.less这个文件总是最后引入，你可以把想要覆盖的类写到这里。 模块化修改为了让修改的内容和原始文件分离开，需要引进模块的方式，这样的好处是如果bootstrap升级的时候，也不影响自定义后的样式文件。由于less文件可以相互引入，因此很容易实现了模块化在bootsrap文件外边平级创建一个custom文件夹，并创建以下文件 custom-variables.less:我从Bootstrap源码中复制了一份variables.less并在这份拷贝中修改变量。 custom-other.less:这个文件中包含了那些无法定义成变量的自定义内容。 custom-bootstrap.less这是新的「核心」文件。我们将把它编译成CSS。与原始的 LESS文件一样，它使用下面的命令来引入上面那两个自定义文件： 1234@import &quot;../bootstrap/less/bootstrap.less&quot;;@import &quot;custom-variables.less&quot;;@import &quot;custom-other.less&quot;;@import &quot;../bootstrap/less/utilities.less&quot;; 这样等bootsrap版本升级的时候也能轻松实现升级。 可视化修改最后提供两个可视化修改bootsrap变量的网站bootswatchr 通过修改变量值实现。stylebootstrap 通过组件化组织内容。 参考资料：http://www.bootcss.com/p/lesscss/#docshttp://www.w3cplus.com/css/customizing-bootstrap.htmlThomas Park 《Customizing Bootstrap》","categories":[],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://arthas.com.cn/tags/bootstrap/"}],"keywords":[]},{"title":"实现类似饿了么网站标题栏的交互","slug":"实现类似饿了么网站标题栏的交互","date":"2016-08-24T14:30:00.000Z","updated":"2016-09-12T16:11:57.743Z","comments":true,"path":"2016/08/24/实现类似饿了么网站标题栏的交互/","link":"","permalink":"http://arthas.com.cn/2016/08/24/实现类似饿了么网站标题栏的交互/","excerpt":"","text":"用到了PageVisibility API。PageVisibility API用于判断页面是否处于浏览器的当前窗口，即是否可见。 属性这个API部署在document对象上，提供以下两个属性。 document.hidden：返回一个布尔值，表示当前是否被隐藏 document.visibilityState：表示页面当前的状态，可以取三个值，分别是visibile（页面可见）、hidden（页面不可见）、prerender（页面正处于渲染之中，不可见）。 VisibilityChange事件当页面的可见状态发生变化时，会触发VisibilityChange事件（带有浏览器前缀）。123document.addEventListener(&quot;visibilitychange&quot;, function() &#123; console.log( document.visibilityState );&#125;); 饿了么网站的页面标题交互效果： 下面是实现页面切换后标题改变的Demo: 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;网页标题处&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var title = document.title; //保存原网页的名称 document.addEventListener(&quot;visibilitychange&quot;, function() &#123; console.log(document.visibilityState); if (document.visibilityState == &apos;hidden&apos; ) &#123; document.title = &apos;不要离开我！！！&apos;; &#125; else if (document.visibilityState == &apos;visible&apos;) &#123; console.log(title); document.title = title; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现的效果： 参考链接阮一峰：Page Visibility API","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/tags/前端/"}],"keywords":[]},{"title":"Hexo修改了样式部署后无效果解决办法","slug":"Hexo修改了样式部署后无效果解决办法","date":"2016-07-30T05:44:11.000Z","updated":"2017-09-01T14:47:40.313Z","comments":true,"path":"2016/07/30/Hexo修改了样式部署后无效果解决办法/","link":"","permalink":"http://arthas.com.cn/2016/07/30/Hexo修改了样式部署后无效果解决办法/","excerpt":"修改完Hexo的样式后本地预览已经显示正常了，hexo deploy后却还是之前的样式，百度一圈之后明白其原因是之前生成部署缓存文件导致的，得到有效的解决办法：1hexo clean 此指令会清楚之前的部署缓存文件，然后在hexo g，hexo d，刷新页面，站点已更新为最新的样式。","text":"修改完Hexo的样式后本地预览已经显示正常了，hexo deploy后却还是之前的样式，百度一圈之后明白其原因是之前生成部署缓存文件导致的，得到有效的解决办法：1hexo clean 此指令会清楚之前的部署缓存文件，然后在hexo g，hexo d，刷新页面，站点已更新为最新的样式。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://arthas.com.cn/tags/Hexo/"}],"keywords":[]},{"title":"彻底解决mysql不能输入中文的问题","slug":"彻底解决mysql不能输入中文的问题","date":"2016-07-16T13:53:30.000Z","updated":"2017-09-02T01:50:35.520Z","comments":true,"path":"2016/07/16/彻底解决mysql不能输入中文的问题/","link":"","permalink":"http://arthas.com.cn/2016/07/16/彻底解决mysql不能输入中文的问题/","excerpt":"用struts2写了一个页面表单提交数据，数据库为MySQL。提交的时候出现了如下报错：1234java.lang.RuntimeException: java.sql.SQLException: Incorrect string value: &apos;\\xE5\\x90\\x83\\xE9\\xA5\\xAD...&apos; for column &apos;hobby&apos; at row 1 Query: insert into students (username,password,gender,hobby,birthday,email,grade) values (?,?,?,?,?,?,?) Parameters: [Ttt, ttt, male, 吃饭,睡觉, null, , 0] at com.itheima.dao.impl.StudentDaoImpl.save(StudentDaoImpl.java:21) at com.itheima.service.impl.BusinessServiceImpl.registStudent(BusinessServiceImpl.java:11) ...... 当把表单内容全部修改为字母时，提交成功。然后在mysql中\\s，查看到如下信息：","text":"用struts2写了一个页面表单提交数据，数据库为MySQL。提交的时候出现了如下报错：1234java.lang.RuntimeException: java.sql.SQLException: Incorrect string value: &apos;\\xE5\\x90\\x83\\xE9\\xA5\\xAD...&apos; for column &apos;hobby&apos; at row 1 Query: insert into students (username,password,gender,hobby,birthday,email,grade) values (?,?,?,?,?,?,?) Parameters: [Ttt, ttt, male, 吃饭,睡觉, null, , 0] at com.itheima.dao.impl.StudentDaoImpl.save(StudentDaoImpl.java:21) at com.itheima.service.impl.BusinessServiceImpl.registStudent(BusinessServiceImpl.java:11) ...... 当把表单内容全部修改为字母时，提交成功。然后在mysql中\\s，查看到如下信息： 1234567891011121314Connection id: 2Current database:Current user: root@localhostSSL: Not in useUsing delimiter: ;Server version: 5.6.11 MySQL Community Server (GPL)Protocol version: 10Connection: localhost via TCP/IPServer characterset: latin1Db characterset: latin1Client characterset: gbkConn. characterset: gbkTCP port: 3306Uptime: 6 min 34 sec 根据报错查找到原因：mysql编码问题。最终解决办法：找到mysql配置文件my.ini，在[mysqld]中添加如下语句：1character-set-server = utf8 继续，找到[mysql]，添加如下语句：1default-character-set = utf8 原因解释：数据库的字符集是什么，表的字符集就是什么，同样MySQL服务器有自己的字符集，他们的优先级从大到小是这样的，MySQL服务器&gt;数据库&gt;表，意思就是，如果不指定数据库的字符集，在创建数据库的时候它会与MySQL服务器的字符集保持一致。通过\\s查看msql服务器的基本信息，注意以下语句： 1234Server characterset: utf8 //MySQL服务器字符集Db characterset: utf8 //数据库字符集Client characterset: utf8 //客户端字符集Conn. characterset: utf8 //客户端连接字符集 通过show create database test查看数据库的字符集，通过show create table user查看表的字符集。 如果在mysql未正确指定字符集的情况下已经创建了某个表，然后又修改了mysql服务器的字符集，存入的数据将会乱码，解决办法是修改此表的字符集和mysql服务器的一致，即utf8，通过以下命令修改 1ALTER TABLE tbl_name CONVERT TO CHARACTER SET charset_name; tbl_name：表名charset_name：字符集名 只要遵循客户端字符集与数据库字符集统一即可解决乱码或者无法输入中文的问题。设置mysql服务器的字符集为utf8，jdbc连接mysql的时候发送字符集为utf-8，客户端show的时候也为utf-8，就不会出现乱码问题了。","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://arthas.com.cn/tags/mysql/"}],"keywords":[]},{"title":"Java web中的常用类名词解释","slug":"Java-web中的常用类名词解释","date":"2016-07-10T02:47:23.000Z","updated":"2017-09-01T14:49:19.482Z","comments":true,"path":"2016/07/10/Java-web中的常用类名词解释/","link":"","permalink":"http://arthas.com.cn/2016/07/10/Java-web中的常用类名词解释/","excerpt":"DBCP（DataBase Connection Pool）数据库连接池。是 apache 上的一个 java 连接池项目，也是 tomcat 使用的连接池组件。单独使用dbcp需要2个包：commons-dbcp.jar,commons-pool.jar由于建立数据库连接是一个非常耗时耗资源的行为，所以通过连接池预先同数据库建立一些连接，放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完后再放回去。","text":"DBCP（DataBase Connection Pool）数据库连接池。是 apache 上的一个 java 连接池项目，也是 tomcat 使用的连接池组件。单独使用dbcp需要2个包：commons-dbcp.jar,commons-pool.jar由于建立数据库连接是一个非常耗时耗资源的行为，所以通过连接池预先同数据库建立一些连接，放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完后再放回去。 Dbutils是Apache组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程序的开发，同时也不会影响程序的性能。传统操作数据库的类指的是JDBC（java database connectivity：java数据库连接，java的数据库操作的基础API。）。 JSTLJSTL（JSP Standard Tag Library，JSP标准标签库)是一个不断完善的开放源代码的JSP标签库，是由apache的jakarta小组来维护的。JSTL只能运行在支持JSP1.2和Servlet2.3规范的容器上，如tomcat 4.x。在JSP 2.0中也是作为标准支持的。","categories":[],"tags":[{"name":"java web","slug":"java-web","permalink":"http://arthas.com.cn/tags/java-web/"}],"keywords":[]},{"title":"Linux下后台运行jar文件","slug":"Linux下后台运行jar文件","date":"2016-07-04T02:34:58.000Z","updated":"2017-09-01T14:54:05.885Z","comments":true,"path":"2016/07/04/Linux下后台运行jar文件/","link":"","permalink":"http://arthas.com.cn/2016/07/04/Linux下后台运行jar文件/","excerpt":"当我们把java程序打成jar包后，放到linux上通过putty或其它终端执行的时候，如果按照：java -jar xxxx.jar执行，当我们退出putty或终端的时候，xxxx.jar这个程序也会停止。为了保证程序能够一直运行，应该改为这样运行： java -jar xxx.jar &amp;命令，则程序会在后台一直运行，值得注意的是，此时程序控制台输出会被转移到nohup.out文件中，这个nohup.out文件的位置就在jar包的当前文件夹内。","text":"当我们把java程序打成jar包后，放到linux上通过putty或其它终端执行的时候，如果按照：java -jar xxxx.jar执行，当我们退出putty或终端的时候，xxxx.jar这个程序也会停止。为了保证程序能够一直运行，应该改为这样运行： java -jar xxx.jar &amp;命令，则程序会在后台一直运行，值得注意的是，此时程序控制台输出会被转移到nohup.out文件中，这个nohup.out文件的位置就在jar包的当前文件夹内。 但是有时候在这一步会有问题，当把终端关闭后，进程会自动被关闭，察看nohup.out可以看到在关闭终端瞬间服务自动关闭。有个操作终端时的细节：当shell中提示了nohup成功后还需要按终端上键盘任意键退回到shell输入命令窗口，然后通过在shell中输入exit来退出终端；而我是每次在nohup执行成功后直接点关闭程序按钮关闭终端。所以这时候会断掉该命令所对应的session，导致nohup对应的进程被通知需要一起shutdown。 当需要关闭这个后台运行的jar文件时，执行以下命令查看目前的所有进程：ps -A找到对应的pid，然后执行以下命令杀死进程：kill -9 pid","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://arthas.com.cn/tags/linux/"}],"keywords":[]},{"title":"解决每次向github提交要输入用户名和密码问题","slug":"解决每次向github提交要输入用户名和密码问题","date":"2016-05-24T02:19:23.000Z","updated":"2017-09-01T14:54:35.950Z","comments":true,"path":"2016/05/24/解决每次向github提交要输入用户名和密码问题/","link":"","permalink":"http://arthas.com.cn/2016/05/24/解决每次向github提交要输入用户名和密码问题/","excerpt":"通过SSH文件的验证方式可以解决每次向github提交都要输入用户名和密码的问题 检查是否存在SSH keys在生成你的SSH key之前，先检查你的电脑上是否存在SSH keys","text":"通过SSH文件的验证方式可以解决每次向github提交都要输入用户名和密码的问题 检查是否存在SSH keys在生成你的SSH key之前，先检查你的电脑上是否存在SSH keys 1ls -al ~/.ssh 如果检测结果是没有，可在后续步骤中生成如果检测结果是有，可直接用于Github配置 生成新的SSH keys 并且添加到ssh-agent中 生成新的SSH keys 1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 出现选择文件路径，用默认路径就可以，按回车 1Enter a file in which to save the key (/Users/you/.ssh/id_rsa): 输入密码时一般没必要输入，直接回车 1Enter passphrase (empty for no passphrase): 重复输入时继续按回车 添加SSH keys到ssh-agent中如果你使用了其他生成工具生成了新的SSH key，就需要设置此代理 1ssh-add ~/.ssh/id_rsa 把SSH key 拷贝到Github网站在电脑中找到刚生成的SSH key ，默认路径为C:\\Users\\mohong\\.ssh，用编辑器打开id_rsa.pub文件，复制内容。 登录Github，找到Setting--SSH and GPG keys，点击创建新的SSH,把内容粘贴在上面，然后起个名字便于多台设备绑定时分辨出设备。 测试SSH连接 1ssh -T git@github.com 第一次使用时，你将会收到以下提示，输入yes即可。123The authenticity of host &apos;github.com (192.30.252.1)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 123The authenticity of host &apos;github.com (192.30.252.1)&apos; can&apos;t be established.RSA key fingerprint is nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? 最后如果看到以下内容，表示绑定成功12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 参考资料","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://arthas.com.cn/tags/git/"}],"keywords":[]},{"title":"Java学习中遇到的困惑","slug":"学习Java过程中遇到的困惑","date":"2016-04-29T09:34:03.000Z","updated":"2017-09-01T15:02:08.982Z","comments":true,"path":"2016/04/29/学习Java过程中遇到的困惑/","link":"","permalink":"http://arthas.com.cn/2016/04/29/学习Java过程中遇到的困惑/","excerpt":"继承（extends）与实现（implements）父类的方法中可以有抽象（abstract）方法，也可以没有抽象方法。当有抽象方法时，这个类就叫做抽象类。假设有一个类的方法既有抽象方法，又有普通方法，如果某子类继承（extends）了该类，且该子类需要创建对象，就必须要实现父类中的所有抽象方法才可创建。Java是单继承的。接口有两个特点：","text":"继承（extends）与实现（implements）父类的方法中可以有抽象（abstract）方法，也可以没有抽象方法。当有抽象方法时，这个类就叫做抽象类。假设有一个类的方法既有抽象方法，又有普通方法，如果某子类继承（extends）了该类，且该子类需要创建对象，就必须要实现父类中的所有抽象方法才可创建。Java是单继承的。接口有两个特点： 接口中所有的属性 默认的修饰符是public static final 接口中所有的方法 默认的修饰符是public abstract所以，实现（implements）接口的时候，必须要把接口中的所有方法都实现，因为接口中定义的所有方法都不能有方法体，默认都是abstract修饰的。一个类可以实现多个接口。有抽象函数的不一定是抽象类，也可以是接口类。 由于接口中的方法默认都是抽象的，所以不能被实例化。如果实现类中要访问接口中的成员，不能使用super关键字。因为两者之间没有显式的继承关系，况且接口中的成员成员属性是静态的。可以使用接口名直接访问。类与类之间的关系是继承（extends）类与接口之间的关系是实现（implements） 接口利用接口可以制定一套规则（标准），避免开发过程中对相同功能的方法起不同的名字。接口可以扩展功能，弥补java单继承中的缺点 例如我定义了一个接口，但是我在继承这个接口的类中还要写接口的实现方法，那我不如直接就在这个类中写实现方法岂不是更便捷，还省去了定义接口？ 接口就是个招牌。比如说你今年放假出去杭州旅游，玩了一上午，你也有点饿了，突然看到前面有个店子，上面挂着KFC，然后你就知道今天中饭有着落了。KFC就是接口，我们看到了这个接口，就知道这个店会卖炸鸡腿（实现接口）。那么为神马我们要去定义一个接口涅，这个店可以直接卖炸鸡腿啊（直接写实现方法），是的，这个店可以直接卖炸鸡腿，但没有挂KFC的招牌，我们就不能直接简单粗暴的冲进去叫服务员给两个炸鸡腿了。要么，我们就要进去问，你这里卖不卖炸鸡腿啊，卖不卖汉堡啊，卖不卖圣代啊（这就是反射）。很显然，这样一家家的问实在是非常麻烦（反射性能很差）。要么，我们就要记住，中山路108号卖炸鸡，黄山路45号卖炸鸡（硬编码），很显然这样我们要记住的很多很多东西（代码量剧增），而且，如果有新的店卖炸鸡腿，我们也不可能知道（不利于扩展）。知乎用户对接口的解释 关于多态多态弊端，只能使用父类引用指向父类成员，指向子类成员是会运行报错。非多态对象强制转换成子类型，引用子类型的特有方法时运行报错，报错信息为：java.lang.ClassCastException instanceof equals ＂＝＂ containsAll()instanceof：判断某个对象是不是由某个类创建的，例如：123if(obj instanceof A)&#123; // 如果obj对象属于A类 System.out.print(&quot;Hello Again! World!!!&quot;);&#125; equals：比较的是对象的内存地址值，返回true或者false。 “=”用于数值比较 containsAll() 判断集合中是否包含指定集合","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://arthas.com.cn/tags/java/"}],"keywords":[]},{"title":"MySQL基础","slug":"MySQL基础","date":"2016-04-26T03:21:16.000Z","updated":"2017-09-01T15:03:11.571Z","comments":true,"path":"2016/04/26/MySQL基础/","link":"","permalink":"http://arthas.com.cn/2016/04/26/MySQL基础/","excerpt":"Structured Query Language 结构化查询语言, 关系型数据库，由标准和扩展部分组成","text":"Structured Query Language 结构化查询语言, 关系型数据库，由标准和扩展部分组成 SQL语句的组成 DQL 数据查询语言 DML 数据操作语言 DDL 数据定义语言 DCL 数据控制语言 TPL 事务处理语言 CCL 指针控制语言 常用数据库 Oracle DB2 MySQL MySQL的安装与配置大小写问题：mysql在windows系统中不区分大小写，但在其他系统中严格区分大小写。验证是否安装配置成功：mysql -u root -p （Hibernate）Java类和表结构对应的Java对象和表中的一条记录是对应的 DDL：数据定义语言作用：用于描述数据库中要存储的现实世界实体的语言。即创建数据库和表的结构常用关键字：CREATE , ALTER , DROP , TRUNCATE 库操作显示所有的数据库：show databases; 创建一个名为mydb1的数据库：create database mydb1; 查看数据库的创建细节，可以看到使用的字符集show create database mydb1; 创建一个使用gbk字符集的mydb2数据库：create database mydb2 character set gbk; 删除前面创建的mydb2数据库：drop database mydb2; 把mydb1的字符集修改为utf8;alter database mydb1 character set utf8; 表操作选择数据库use mydb1; 显示当前选择的数据库select database(); 创建一个员工表：123456789create table employee( id int, name varchar(100), gender varchar(10), birthday date, job varchar(100), salary float(8,2), resume text); 查看库中的所有表格show tables; 查看表的结构desc employee; 查看表的创建细节show create table employee; 添加一个image列alter table employee add image blob; 修改job列的长度为60alter table employee modify job varchar(60); 删除image列alter table employee drop image; 表名改为userrename table employee to user; 修改表的字符集为utf8alter table user character set utf8; 修改列名name为usernamealter table user change name username varchar(100); DML：数据操作语言作用：向数据库中插入、删除、修改数据常用关键字：insert ,update,delete注意： mysql中，字符串或者日期要包含在单引号中 空值的表示为：null 使用insert语句向表中插入三个员工的信息 insert into user values (1,&#39;tom&#39;,&#39;female&#39;,&#39;1992-3-9&#39;,&#39;CTO&#39;,&#39;1000&#39;,&#39;developer&#39;); insert into user (id,username,gender,birthday,job,salary,resume) values (2,&#39;jack&#39;,&#39;male&#39;,&#39;1993-3-9&#39;,&#39;CTO&#39;,&#39;2000&#39;,&#39;developer&#39;); insert into user (id,username,gender,birthday,job,salary,resume) values (3,&#39;Lili&#39;,&#39;female&#39;,&#39;1993-3-9&#39;,&#39;CTO&#39;,&#39;2000&#39;,&#39;developer&#39;); 12345678910111213mysql&gt; show variables like &apos;character%&apos;;+--------------------------+--------------------------------+| Variable_name | Value |+--------------------------+--------------------------------+| character_set_client | gbk 客户端使用的编码| character_set_connection | gbk 数据库连接时使用的编码| character_set_database | utf8 数据库使用的编码| character_set_filesystem | binary | character_set_results | gbk 查询结果集使用的编码| character_set_server | latin1 服务器使用的编码| character_set_system | utf8 系统使用的编码| character_sets_dir | E:\\xampp\\mysql\\share\\charsets\\ |+--------------------------+--------------------------------+ 告知服务器客户端使用的编码：set character_set_client=gbk; 告知服务器返回的结果集使用gbk：set character_set_results=gbk 查看表中的所有记录select * from user; 将所有员工的薪水修改为3000：update user set salary=3000; 将姓名为“tom”的员工薪水改为2500：update user set salary=2500 where username=&#39;tom&#39;; 将姓名为”jack” 的员工薪水改为3200，job改为front-end：update user set salary=4000,job=&#39;font-end&#39; where username=&#39;jack&#39;; 将Lili的薪水在原有的基础上增加1000：update user set salary=salary+1000 where username=&#39;Lili&#39;; 删除表中用户名为Lili的记录：delete from user where username=&#39;Lili&#39;; 删除表中所有记录：delete from user; 使用truncate删除表中记录(摧毁整张表格，重新建立表结构)truncate table user; DQL 数据查询语言Date Query Language作用：查询数据，返回结果集常用关键字：select 查询所有学生的信息select * from student; 查询表中所有学生的姓名和对应的英语成绩select name,english from student; 过滤表中重复的数据select distinct english from student; 给所有学生数学分数加上10分特长分select name,math+10 from student; 统计每个学生的总分select name,chinese+english+math from student; 使用别名表示学生分数select name as 姓名,chinese+english+math 总分 from student; 查询id=1的学生信息select * from student where id=1; 查询英语分数在80-90之间的学生信息select * from student where english between 80 and 90; 查询数学成绩为89，90,91的学生信息select * from student where math in (89,90,91); 查询姓李的学生信息select * from student where name like &#39;李%&#39;; 查询数学成绩大于80，语文成绩大于80的学生select * from student where math&gt;80 and chinese&gt;80; 对数学成绩排序输出select name,math from student order by math; 对总分排序从高到低倒序输出select name as 姓名,chinese+english+math 总分 from student order by 总分 desc; 数据完整性数据完整性是为了保证插入到数据中的数据是正确的，它放防止了用户可能的输入错误。 实体（行）完整性规定表的一行（即每一条记录）在表中是唯一的实体。通过定义主键约束来实现主键：primary key （不能为null,且唯一） 逻辑主键：比如ID，不代表实际的业务意义，只是用来标识唯一的一条记录（推荐使用） 业务主键：比如username作为主键实现方式1：1234create table t1( id int primary key, name varchar(100) ); 实现方式2：可以定义联合主键12345create table t2( id int, name varchar(100), primary key (id)); 实现方式3：（推荐）12345create table t3( id int, name varchar(100));alter table t3 add primary key (id); 主键自增（Oracle没有）1234create table t4( id int primary key auto_increment, name varchar(100)); 域（列）完整性指数据库表的列（即字段）必须符合某种特定的数据类型或约束数据类型长度非空约束（not null）唯一约束（unique） 12345create table t5( username varchar(100) not null unique, gender varchar(100), phonenumber varchar(100)); 参照完整性（多表）外键约束多表设计：一对多，多对多，一对一一对多： 12345678910111213create table customers( id int, name varchar(100), address varchar(255));create table orders( id int primary key, order_num varchar(100), price float(8,2), status int, customer_id int, constraint customer_id_fk foreign key(customer_id) references customers(id)); 多表查询链接查询 交叉链接 （隐式查询，不使用关键字）：select * from customers,orders; 内链接：select * from customers c,orders o where c.id=o.customer_id; 外链接：左外：返回符合链接条件的记录，同时返回左表中不满足链接条件的剩余记录右外： 几个简单的查询 嵌套查询 子查询的语句放到小括号之内。 联合查询 报表查询 分组统计统计一个班共有多少学生？select count(*) from student; 统计数学成绩大于90分的学生共有多少个select count(*) from student where math&gt;90; 统计一个班的数学总成绩select sum(math) from student ; 注意：可以使用反引号把关键字引起来，当做普通字符串对待","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://arthas.com.cn/tags/mysql/"}],"keywords":[]},{"title":"什么是webView","slug":"什么是webview","date":"2016-04-05T09:01:11.000Z","updated":"2017-09-01T15:09:12.868Z","comments":true,"path":"2016/04/05/什么是webview/","link":"","permalink":"http://arthas.com.cn/2016/04/05/什么是webview/","excerpt":"在Android手机中内置了一款高性能webkit内核浏览器，在SDK中封装为一个叫做WebView（网络视图）的组件。Android4.4的内核是chrome内核，Android4.4以下是Android webkit内核。A View that displays web pages. This class is the basis upon which you can roll your own web browser or simply display some online content within your Activity. It uses the WebKit rendering engine to display web pages and includes methods to navigate forward and backward through a history, zoom in and out, perform text searches and more.","text":"在Android手机中内置了一款高性能webkit内核浏览器，在SDK中封装为一个叫做WebView（网络视图）的组件。Android4.4的内核是chrome内核，Android4.4以下是Android webkit内核。A View that displays web pages. This class is the basis upon which you can roll your own web browser or simply display some online content within your Activity. It uses the WebKit rendering engine to display web pages and includes methods to navigate forward and backward through a history, zoom in and out, perform text searches and more. 事件webView加载时有3个事件： loading 开始载入页面时触发 titleupdate 载入过程中title已经解析并赋予新值，则触发titleupdate loaded 载入完毕触发loaded 作用利用webView的这种方式在有些时候UI布局就可以转成相应的html代码编写了，在UI和视觉效果上就会节省很多时间，而且可以和js交互，为前端打开了一扇大门，于是乎，前端人员华丽丽的开始了移动应用开发。 开发（Hbuilder） webView是调用原生界面的H5+对象 单个webView只承载单个页面的DOM，多个webView可以组合，套嵌 页面之间会相互遮挡，所以大小很重要 要想使界面流畅，就要合理组合使用webView","categories":[],"tags":[{"name":"webwiew","slug":"webwiew","permalink":"http://arthas.com.cn/tags/webwiew/"}],"keywords":[]},{"title":"CSS之绝对定位和相对定位","slug":"CSS之绝对定位和相对定位","date":"2016-03-27T13:25:06.000Z","updated":"2018-03-14T06:13:25.477Z","comments":true,"path":"2016/03/27/CSS之绝对定位和相对定位/","link":"","permalink":"http://arthas.com.cn/2016/03/27/CSS之绝对定位和相对定位/","excerpt":"","text":"CSS中的定位方式有相对定位(relative)和绝对定位(absolute) 相对定位：position: relative 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或者水平位置，让这个元素“相对于”它的起点移动。在使用相对定位时，无论是否移动，元素任然占据原来的空间，因此，移动元素会导致它覆盖其他框。 例如： 12345#div2 &#123; position: relative; left: 20px; top: 20px;&#125; 绝对定位：position:absolute 相对定位实际上被看做普通流定位模型的一部分，因为元素的位置是相对于它在普通流中的位置的。与之相反，绝对定位使元素的位置与文档流无关，因此不占据空间。绝对定位的元素的位置是相对于距离它最近的那个已定位的祖先元素确定的。 例如： 12345#div2 &#123; position: absolute; left: 20px; top: 20px;&#125; 因为绝对定位的框与文档流无关，所以它们可以覆盖页面上的其他元素，可以通过设置z-index属性来控制这些框的叠放次序。z-index的值越高，框在栈中的位置就越高。 如果要相对于相对定位的框的右边或者底部设置绝对定位的框的位置，那么需要确保相对定位的框已经设置了尺寸。如果没有，那么IE会错误地相对于画布定位这个框。","categories":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://arthas.com.cn/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/categories/前端/"}]},{"title":"Linux学习笔记","slug":"Linux学习笔记","date":"2016-03-24T07:53:58.000Z","updated":"2017-09-01T15:09:41.678Z","comments":true,"path":"2016/03/24/Linux学习笔记/","link":"","permalink":"http://arthas.com.cn/2016/03/24/Linux学习笔记/","excerpt":"","text":"1、Ubuntu的图形模式与字符模式切换 ctrl+alt+f2进入命令行模式 ctrl+alt+f7进入到图形模式 2、使用root终端：sudo -i 3、shutdown -t seco 设定在seco秒之后关机 -r 重启 -h 关机 man shutdown 帮助 4、软件安装包Linxu安装软件包文件有许多不同的类型。他们多数与特定Linux发行版的软件管理器相关联， Debian软件包文件为.deb （ubuntu主要包） RedHat软件包文件为.rpm Tarballs软件包文件为.tar 5、APT APT(The Advanced Packaging Tool 高级软件包工具)是一个强大的包管理系统，图形化程序如添加/删除应用程序和Synictic都是建立在其基础之上，APT会自动处理依赖关系，APT由名字以“apt-”打头的程序组成， Aptitude为一个高级包管理工具，也是目前首选的字符界面APT前端程序，它会记住哪些包是你安装的，哪些是为了满足依赖关系而安装的。在已安装包不需要的情况下，Aptitude会自动卸载后者。Aptitude完全可以作为apt-get的替代品。 APT的一些常用操作命令 查看软件的信息：sudo apt-cache showsrc 获取源代码： sudo apt-get source 安装软件包： sudo apt-get install 获取新的软件包列表： sudo apt-get update 6、安装软件Ubuntu相关的软件包文件名使用.deb作为后缀，这是因为Ubuntu和Debian发行版有着紧密的联系。dpkg(debian package)是为Debian系统专门开发的软件包。 安装软件包 1sudo dpkg -i &lt;package&gt; 删除软件包 1sudo dpkg -i &lt;package&gt; 7、alien转换包不建议安装rpm包，因为debian的包已经很多了，但是当只有rpm包的时候，又需要安装到ubuntu上的时候，就需要用alien把rpm包转换为deb包，再安装。 alien也可以指在linux下运行的一款软件。它的作用是对现有流行的linux软件发行格式——如rpm,deb,tgz等进行转换。可以帮助某一发行版的linux用户转换由其它linux发行版发行的软件来使用（如在debian上安装由fedora(Red Hat)主推的rpm格式软件），以保证软件的格式兼容。 安装alien1sudo apt-get install alien 通过alien将rpm包转换成deb包：1sudo alien package_file.rpm 生成同名的.deb文件1sudo dpkg -i package_file.deb 8、修改源备份当前的源列表文件1sudo cp -p /etc/apt/sources.list /etc/apt/sources.list_bak (ubuntu用户)用文本编辑器修改源文件1sudo gedit sources.list 注意：将不同软件源混杂在一起可能导致系统崩溃 9、更新1sudo apt-get update 这个命令（换源后必须执行），会访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑。我们在新立得软件包管理器里看到的软件列表，都是通过update命令更新的。接着： 1sudo apt-get upgrade 这个命令，会把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。upgreade可不能乱用，要是源里面有系统更新，直接会把系统升级了。 9、搜索搜索所有包含xxx的文件或文件夹1locate xxx 10、多命令执行 分号使用方式：command1 ; command2先执行command1,不管command1会不会出错，都会执行command2 &amp;&amp;使用方式：command1 &amp;&amp; command2只有当command1正确运行完毕后才执行command2 11、文件查找find命令从指定的起始目录开始，递归的搜索其各个子目录，查找满足查找条件的文件并对其采取相关操作。语法：1find [路径] [参数] 参数 -amin n : 查找n分钟以内被访问的文件 -name ‘字符串’：查找文件名匹配所给字符串的所有文件，字符串内可以用通配符？*和[] -user ‘字符串’ ： 查找属于用户名为所给字符串的所有文件 which命令基本功能是从系统变量path中指定的路径去寻找可执行文件，简单来说，其基本功能在于查找可执行文件，语法：1which [文件名称] whereis用于查找一个指定文件名的文件1whereis [-bmsu] [目录名称] 12、查看某个目录的大小1du -s [-h][-m] 默认是以k为单位的， -s : 省略子文件的显示 -h : 用人类能读懂的方式显示[human readable] -m : 以M为单位显示 13、前后台管理 &amp;用户将屏幕中的命令（command）在后台执行，可通过fg让该程序切换到前台执行 ctrl+z用户将一个前台正在执行的命令放到后台，并且暂停 jobs用来查看当前有多少命令在后台执行 14、进程管理 psps指令和top指令都用来监视系统进程和资源使用情况。ps更为常用。1ps -aux 显示所有包含其他用户的进程 top动态显示系统进程和资源信息 free [-k][-m][-h]查看当前内存情况 kill -9 pid用于杀死pid进程，和ps、pgrep结合在一起使用 whowho和w用来查看目前系统上的用户","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://arthas.com.cn/tags/linux/"}],"keywords":[]},{"title":"快速掌握Git基础操作","slug":"快速掌握Git基础操作","date":"2015-10-17T09:31:03.000Z","updated":"2017-09-02T01:49:18.726Z","comments":true,"path":"2015/10/17/快速掌握Git基础操作/","link":"","permalink":"http://arthas.com.cn/2015/10/17/快速掌握Git基础操作/","excerpt":"常用的Git命令","text":"常用的Git命令 初始化配置$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 创建版本库（初始化仓库）windows系统下仓库路径不要出现中文$git init 把文件添加到版本库 添加所有改动过的文件$git add .提交到版本库$git commit -m &quot;message&quot; 查看修改结果查看修改状态$git status查看具体修改内容`$git diff filename.txt 版本回退版本历史记录$git log --oneline --decorate --graph回退到上一个版本$ git reset --hard HEAD^重返未来$git reflog 撤销修改 未执行$git add .时，丢弃工作区的修改当还没有提交到暂存区时，会和版本库一样当提交到暂存区时，会回到添加暂存区后的状态 $git checkout -- readme.txt $git checkout -- . 执行了$git add .，但未commit把暂存区的修改撤销，重新放回工作区 $git reset HEAD file.txt 执行了commit， 版本回退 删除文件 从本地直接删除（此时工作区和版本库不一致） 确实要从版本库中删除文件 $git rm -rf test.txt $git commit -m &quot;message&quot; 删错了想恢复 $git checkout -- test.txt 远程仓库 创建SSH key 生成SSH key $ssh-keygen -t rsa -b 4096 -C &quot;your email@com&quot; 绑定在github网站 检测是否绑定成功 $ssh -T git@github.com 添加远程库 在github上新建一个仓库，如learn.git 在本地learn.git仓库中运行下列语句来关联远程库 $git remote add origin git@github.com:qinzhongjie/learngit.git 把本地仓库中所有内容推送到远程库 首次推送，-u为了关联两个仓库 $git push -u origin master 以后的推送 $git push origin master 克隆远程库 $git clone git@github.com:qinzhongjie/learngit.git 注意： .gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。 正确的做法是在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。 git update-index –assume-unchanged PATH 在PATH处输入要忽略的文件。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://arthas.com.cn/tags/git/"}],"keywords":[]}]}