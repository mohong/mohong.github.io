{"meta":{"title":"学海无涯","subtitle":"墨鸿的博客","description":"墨鸿的博客","author":"墨鸿","url":"http://arthas.com.cn"},"pages":[{"title":"","date":"2017-09-01T15:49:02.000Z","updated":"2017-09-02T02:47:46.030Z","comments":true,"path":"about/index.html","permalink":"http://arthas.com.cn/about/index.html","excerpt":"","text":"微博@墨鸿001 Github@mohong 站酷@mohong Segmentfault@墨鸿 email: arthas_qin@qq.com"}],"posts":[{"title":"UML类图教程","slug":"UML类图教程","date":"2018-01-18T15:30:07.000Z","updated":"2018-02-13T09:08:18.721Z","comments":false,"path":"2018/01/18/UML类图教程/","link":"","permalink":"http://arthas.com.cn/2018/01/18/UML类图教程/","excerpt":"","text":"矩形框代表一个类，类图分三层，第一层显示类名称，如果是抽象类，用斜体显示，第二层是类的特性，通常是字段和属性。第三层是类的操作，通常是方法或行为。前面的符号‘+’表示public，‘-’表示private，‘#’表示protected。 一、简介UML类图中存在着六大关系：关联(association)、聚合(aggregation)、组合(composition)、依赖(dependency)、泛化(generalization)/继承(inheritance)和实现(realization)，分别用如下图示表示： (关联)Association：A类有B类有逻辑上的连接(当一个类知道另一个类时使用关联) (聚合)Aggregation : A类有一个B类 (组合)Composition : A类拥有一个B类 (依赖)Dependency : A类使用了B类 (继承)Inheritance : B类是一个A类 (或者B类扩展A类) (实现)Realization : B类实现了接口A 二、关联(association) 关联描述两个类之间行为的一般二元关系。例如，一个学生选修一门特定的课程是学生类Student和课程类Course之间的一个关联，而一个教师教授一门课程是师资类Faculty和课程类Course之间的一个关联。Java代码中，关联可以用属性和方法来实现。 12345678910111213141516171819202122232425262728public class Student &#123; private Course[] courses; public void addCourse(Course s) &#123; . . . . . . &#125;&#125;public class Course &#123; private Strudent[] students; private Faculty faculty; public void addStudent(Student s) &#123; . . . . . . &#125; public void setFaculty(Faculty faculty) &#123; this.faculty = faculty; &#125;&#125;public class Faculty &#123; private Course[] courses; public void addCourse(Course s) &#123; . . . . . . &#125; &#125; 三、聚合(Aggregation) 聚合是一种特殊的关联(Association)形式，表示两个对象之间的所属(has-a)关系。所有者对象称为聚合对象，它的类称为聚合类；从属对象称为被聚合对象，它的类称为被聚合类。例如，一个公司有很多员工就是公司类Company和员工类Employee之间的一种聚合关系。被聚合对象和聚合对象有着各自的生命周期，即如果公司倒闭并不影响员工的存在。 1234567public class Company &#123; private List&lt;Employee&gt; employees;&#125;public class Employee &#123; private String name; &#125; 四、组合(Composition) 聚合是一种较弱形式的对象包含(一个对象包含另一个对象)关系。较强形式是组合(Composition). 在组合关系中包含对象负责被包含对象的创建以及生命周期，即当包含对象被销毁时被包含对象也会不复存在。例如一辆汽车拥有一个引擎是汽车类Car与引擎类Engine的组合关系。下面是组合的一些例子。 (1)通过成员变量初始化 1234567public class Car &#123; private final Engine engine = new Engine(); &#125;class Engine &#123; private String type;&#125; (2)通过构造函数初始化 1234567891011public class Car &#123; private final Engine engine; public Car()&#123; engine = new Engine(); &#125;&#125;public class Engine &#123; private String type;&#125; (3)通过延迟初始化 12345678910111213public class Car &#123; private final Engine engine; public Engine getEngine() &#123; if (null == engine) &#123; engine = new Engine(); &#125; return engine; &#125; &#125;public class Engine &#123; private String type;&#125; 五、依赖(Dependency) 依赖(Dependency)描述的是一个类的引用用作另一个类的方法的参数。例如，可以使用Calendar类中的setTime(Date date)方法设置日历，所以Calendar和Date之间的关系可以用依赖描述。 12345678public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; &#123; public final void setTime(Date date) &#123; setTimeInMillis(date.getTime()); &#125; . . . . . .&#125; 在依赖关系中，类之间是松耦合的。 六、继承(Inheritance) 继承(Inheritance)模拟两个类之间的is-a关系。强是(strong is-a)关系描述两个类之间的直接继承关系。弱是(weak is-a)关系描述一个类具有某个属性。强是关系可以用类的继承表示。例如，Spring的ApplicationEvent是一个EventObject，ApplicationEvent和EventObject间就是一种强是关系，可以用继承描述 123public abstract class ApplicationEvent extends EventObject &#123; . . . . . .&#125; 七、实现(Realization) 实现(Realization)描述的是一个类实现了接口（可以是多个）。上面描述的弱是(weak is-a)关系就可以用接口表示。例如字符串是可以被序列化的，这就可以用实现来描述。 123public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; . . . . . .&#125; 八、参考资料UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现 UML类图关系（泛化 、继承、实现、依赖、关联、聚合、组合）","categories":[{"name":"设计","slug":"设计","permalink":"http://arthas.com.cn/categories/设计/"}],"tags":[{"name":"UML","slug":"UML","permalink":"http://arthas.com.cn/tags/UML/"}],"keywords":[{"name":"设计","slug":"设计","permalink":"http://arthas.com.cn/categories/设计/"}]},{"title":"JavaScript之Event对象","slug":"JavaScript之Event对象","date":"2018-01-15T12:38:06.000Z","updated":"2018-01-15T13:01:17.122Z","comments":true,"path":"2018/01/15/JavaScript之Event对象/","link":"","permalink":"http://arthas.com.cn/2018/01/15/JavaScript之Event对象/","excerpt":"","text":"Event接口表示在DOM中发生的任何事件; 一些是用户生成的（例如鼠标或键盘事件），而其他由API生成(例如指示动画已经完成运行的事件，视频已被暂停等等)。有许多类型的事件，其中一些使用基于主要事件接口的其他接口。事件本身包含所有事件通用的属性和方法。 注册事件监听器有三种方式可以为DOM元素注册事件处理函数。(// Assuming myButton is a button element) EventTarget.addEventListener myButton.addEventListener(‘click’, function(){alert(‘Hello world’);}, false); HTML 属性 &lt;button onclick=&quot;alert(&#39;Hello world!&#39;)&quot;&gt; DOM 元素属性 myButton.onclick = function(event){alert(‘Hello world’);}; DOM Event 接口属性 Event.bubbles 只读 一个布尔值，用来表示该事件是否在DOM中冒泡。 …… 方法 event.initEvent 通过DocumentEvent的接口给被创建的事件初始化某些值。 event.preventDefault 取消事件（如果该事件可取消）。 event.stopPropagation 停止事件冒泡","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://arthas.com.cn/tags/JavaScript/"}],"keywords":[]},{"title":"单反课程笔记","slug":"单反课程笔记","date":"2017-12-10T03:10:46.000Z","updated":"2017-12-10T03:18:32.058Z","comments":true,"path":"2017/12/10/单反课程笔记/","link":"","permalink":"http://arthas.com.cn/2017/12/10/单反课程笔记/","excerpt":"基本概念测光模式: 评价测光 局部测光 点测光 中央重点测光 光线均匀的时候用评价测光;背光比较严重，发差比较大的时候用局部测光或者点测光;人物放在中间的时候用中央重点测光; 白平衡: 用来控制相机的色彩还原，因为物体受到了环境色的影响 自动对焦:ONE SHOT AI FOCUS AI SERVO ONE SHOT 单次对焦，用于拍摄运动幅度不大的物体，比如静物 AI FOCUS 用于拍摄无法预知的物体，比如小孩 AI SERVO 连续对焦 用于拍摄连续运动的物体，比如运动的车 注：只要运动幅度不大，尽量使用单次对焦","text":"基本概念测光模式: 评价测光 局部测光 点测光 中央重点测光 光线均匀的时候用评价测光;背光比较严重，发差比较大的时候用局部测光或者点测光;人物放在中间的时候用中央重点测光; 白平衡: 用来控制相机的色彩还原，因为物体受到了环境色的影响 自动对焦:ONE SHOT AI FOCUS AI SERVO ONE SHOT 单次对焦，用于拍摄运动幅度不大的物体，比如静物 AI FOCUS 用于拍摄无法预知的物体，比如小孩 AI SERVO 连续对焦 用于拍摄连续运动的物体，比如运动的车 注：只要运动幅度不大，尽量使用单次对焦 ISO 天气晴朗的室外，100-400 阴天或傍晚 400-1600 黑暗的室内或者夜晚 1600-6400.H（H表示扩展ISO） 原则：只要光线允许，都应该让ISO的值越低，高了就会有噪点 闪光补偿:用来配合闪光灯使用，闪光灯打过了，给负补偿，闪光灯不足，给正补偿在目镜中观察标尺，左边表示光线不足，右边表示光线过大 历史小孔成像 机身和镜头的详细介绍卡口环 快门键 热靴 取景器 肩屏 脚架螺口（通用） 电池仓 镜头 焦距: 焦距越长，镜头的视角越窄；焦距越短，镜头的视角越宽 以焦距为标准的镜头分类 按聚焦局是否可变：变焦镜头、定焦镜头 按焦距长短：广角、标准、中焦、长焦 按特殊用途：微距镜头、移轴镜头 广角：全幅28mm焦距 非全幅28mm/1.6 标准：全幅50mm焦距 非全幅50mm/1.6 中焦：全幅85mm-135mm 非全幅=全幅/1.6 长焦：全幅135mm焦距 非全幅135mm/1.6 靠的近：会变形，尴尬，无法对焦 自动对焦: 非常暗的地方，没有层次的物体，透过玻璃拍 这些情况需要用手动对焦 四、快门、光圈与各种曝光模式光圈光圈是一个用来控制光线透过镜头，进入机身内感光面的光亮的装置，它在镜头内。光圈的值越大，进光越小；光圈的值越小，进光越大； 1:3.5-5.6 非恒定光圈焦距为18的时候，光圈能达到3.5；焦距为135的时候，光圈为5.6变焦的过程中光圈会改变景深：画面中纵向上静物清晰的范围光圈越大，景深越小；光圈越小，景深越大。通过大光圈拍摄小景深照片，背景很模糊的照片，净化构图。 快门与光圈的成级变化：T：1/2 1/4 1/8 1/15 1/30 1/60 1/125 1/250 ……F: 1 1.4 2 2.8 4 5.6 8 11 16 22……..快门通过控制进光时间控制进光量快门可以决定画面的亮度快门速度越高，画面越清晰；快门速度越低，画面越模糊高速快门拍瞬间，低速快门记录轨迹 拨盘AV 光圈优先模式光圈值手动，快门相机定 光圈先决直接影响到景深的大小拍人用大光圈，如F2.7 F2.8 ,拍摄风景可以用小光圈，如F11 F12光圈值大于8时可以叫小光圈 TV 快门优先模式高速运动的物体使用高速的快门拍摄一个不动的人，一般1/60s就可以拍摄一个缓步行走的人1/125s拍摄一个跑动的人1/250s拍摄一辆行驶的汽车1/400s1s能把水流拍摄的像绸缎一样 当快门开到很高时，如果出现光圈值闪烁，说明即使把光圈值开到最大，也无法正常曝光，此时需要降低快门速度以获得正确曝光。 曝光补偿：拍摄黑色物体时可以给一点负的曝光补偿，拍摄白色物体时可以给点正的曝光补偿 五、像素、白平衡、相对感光度P档下可以自由设置参数，A档（傻瓜档）无法设置 画幅1、画幅越大，能够实现的像素值越高2、同等条件下，画幅大的影像品质高3、画幅越大，广角优势越明显 注：数码相机可以更改像素，但并非缩小画幅。 感光度提速快门，抓拍运动的物体只要光线允许，尽量使用低的ISO，多用脚架，ISO只是手持的时候辅助曝光。 白平衡数码相机专有的功能固有色还原，条件色还原任何情况下，使用日光灯，条件色的还原 拍摄晚霞的时候，使用“阴天”会让晚霞更红，因为阴天有一部分蓝色，相机为了中和蓝色，会多用一下黄色暖光中和，导致画面更红。 夜景，色温值设的越低，相机会做冷色补偿，画面偏蓝色 色温值设的越高，相机会做暖调的补偿，画面偏红 六、景深原理与对焦景深的三要素 1、景深与光圈成反比2、景深与焦距成反比3、景深与拍摄距离（对焦距离）成正比 焦点的选择七、曝光补偿与手动模式M档曝光补偿将失效M档设置参数时参考内置的游标，箭头在左表示曝光不足，此时当放慢快门，放大光圈，或者增加ISO；箭头在右表示曝光过度此时当增加快门，缩小光圈，或者减小ISO; 中间灰 白加黑减中间灰色不补充*键锁定曝光 八、测光模式测光模式的选择1、评价测光 也叫平均测光，适用于受光均匀的场景。 2、局部测光3、 点测光适用于反差很大的场景，是非常极端的测光方式，只测算焦点附近的区域，如逆光拍摄， 剪影等 只测量5%-15%佳能相机取取景器中心的点测光，当焦点不在取景器中心时，使用*键（曝光锁定键）先锁定曝光，然后再对焦4、中央重点测光适用于稍微有点反差，偏重于画面中心的位置，兼顾周围环境 九、夜景摄影与夜景人像摄影相机配置：宜广角镜头、配三脚架机身设置：1、一般使用低的ISO控制画面的细腻度，并实现长时间曝光；2、阳光模式还原条件色、高温色呈现暖调、低色温表现冷调；3、单次对焦、如失效使用手动对焦；4、平均测光（评价测光、3D矩阵测光，加权测光……）；5、小光圈实现慢快门并将光圈表现出星芒、大光圈拍摄局部特写，营造虚化背景的梦幻效果；6、按测光表反馈获得，根据画面亮度做补偿；7、三脚架、快门线、中灰滤镜、黑卡纸。 注意：打开相机的“长时间曝光进行降噪”功能； 夜景摄影没有苛刻的曝光要求，自己决定； 避开大功率光源； 入夜是拍摄夜景的最佳时机； 当把相机架在三脚架上后一定要关闭防抖，否则会适得其反； 人像摄影快门优先 1、稍高的ISO（如400-800），稍大的光圈（如F4，F2.8）拍摄夜景，找出合适的快门，在此快门基础上减少一到两级曝光；2、WB设置闪光灯模式；3、以人物对焦；4、开启闪光灯，设置后帘同步；5、试拍摄，按照画面亮度做出闪光补偿；","categories":[],"tags":[{"name":"摄影","slug":"摄影","permalink":"http://arthas.com.cn/tags/摄影/"}],"keywords":[]},{"title":"Algorithms笔记","slug":"Algorithms笔记","date":"2017-12-06T06:55:21.000Z","updated":"2017-12-07T14:44:02.726Z","comments":true,"path":"2017/12/06/Algorithms笔记/","link":"","permalink":"http://arthas.com.cn/2017/12/06/Algorithms笔记/","excerpt":"一个时间复杂度的问题有一个字符串数组，将数组中的每一个字符串按照字母序排序，之后再将整个字符串数组按照字典序排序，求整个操作的时间复杂度。 假设最长的字符串长度为s，数组中有n个字符串对每个字符串排序：O(slogs)将数组中每一个字符串按照字母序排序：O(nslog(s))将整个字符串数组按照字典序排序：O(snlog(n)) (因为字符串长度为s)所以，整个操作的时间复杂度为：O(n*slog(s)) + O(s*nlog(n)) = O(n*s(logs+logn))","text":"一个时间复杂度的问题有一个字符串数组，将数组中的每一个字符串按照字母序排序，之后再将整个字符串数组按照字典序排序，求整个操作的时间复杂度。 假设最长的字符串长度为s，数组中有n个字符串对每个字符串排序：O(slogs)将数组中每一个字符串按照字母序排序：O(nslog(s))将整个字符串数组按照字典序排序：O(snlog(n)) (因为字符串长度为s)所以，整个操作的时间复杂度为：O(n*slog(s)) + O(s*nlog(n)) = O(n*s(logs+logn)) 常见算法复杂度：二分查找法：O(logn)寻找数组中的最大值/最小值：O(n)归并排序算法：O(nlogn)选择排序法：O(n^2) 算法复杂度在有些情况下是与用例相关的 场景 插入排序算法O(n^2) 快速排序算法O(nlog(n)) 最差情况 O(n^2) O(n^2) 最好情况 O(n) O(nlog(n)) 平均情况 O(n^2) O(nlog(n)) 数据规模的概念如果想要在1s内解决问题：O(n^2)的算法可以处理大约10^4(万)级别的数据O(n)的算法可以处理大约10^8(千万)级别的数据O(nlog(n))的算法可以处理大约10^7(百万)级别的数据 空间复杂度递归的调用是有空间代价的空间复杂度O(1)12345678int sum1 (int n) &#123; assert(n &gt;= 0); int ret = 0; for (int i = 0; i &lt;= n; i++) &#123; ret += i; &#125; return ret;&#125; 空间复杂度为O(n)1234567int sum2 () &#123; assert(n &gt;= 0); if (n === 0) &#123; return 0; &#125; return n + sum2(n-1);&#125; 求以下算法的时间复杂度12345678public void sayHelloWorld() &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 30; j++) &#123; System.out.println(&quot;hello world&quot;); &#125; &#125;&#125;// O(n) 二分查找法的时间复杂度：O(logn) 均摊复杂度","categories":[],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://arthas.com.cn/tags/Algorithms/"}],"keywords":[]},{"title":"Nginx反向代理实现Tomcat集群","slug":"Nginx反向代理实现Tomcat集群","date":"2017-01-17T04:52:22.000Z","updated":"2017-03-22T16:06:39.649Z","comments":true,"path":"2017/01/17/Nginx反向代理实现Tomcat集群/","link":"","permalink":"http://arthas.com.cn/2017/01/17/Nginx反向代理实现Tomcat集群/","excerpt":"对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。","text":"对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。 反向代理有两个作用： 保护和隐藏原始资源服务器 负载均衡 Nginx Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。 基本操作 双击nginx.exe启动（windows下） nginx -s stop关闭 nginx -s reload在不关闭nginx的情况下更新配置文件 搭建集群修改tomcat配置文件准备好需要搭建集群的tomcat，分别修改端口号以避免端口冲突。 进入tomcat*/conf/server.xml，修改如下信息： port修改成没有占用的:1&lt;Server port=&quot;8006&quot; shutdown=&quot;SHUTDOWN&quot;&gt; 修改port参数123&lt;Connector port=&quot;9999&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 修改port参数1&lt;Connector port=&quot;8010&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; 加入jvmRoute=&quot;tomcat*，值相当于给tomcat起了个名字，1&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcat*&quot;&gt; 修改完所有的tomcat参数，假设配置了两个tomcat，分别起名为tomcat1,tomcat2。 修改Nginx配置文件打开nginx配置文件nginx/conf/nginx.conf,123456789101112131415161718upstream server_lb&#123; server 127.0.0.1:8888 weight=10; //集群的地址和端口 server 127.0.0.1:9999 weight=5; //weight表示权重 &#125; server &#123; listen 80; server_name localhost; //网站域名 #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; proxy_pass http://server_lb; //实现反向代理 index index.html index.htm; &#125; session共享tomcat中session共享最简单的方法是修改tomcat的server.xml文件，去掉以下代码的注释，使其生效即可1&lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;/&gt;","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://arthas.com.cn/tags/Nginx/"}],"keywords":[]},{"title":"设备像素比的实际意义","slug":"设备像素比的实际意义","date":"2016-12-17T11:44:32.000Z","updated":"2017-09-02T01:48:50.538Z","comments":true,"path":"2016/12/17/设备像素比的实际意义/","link":"","permalink":"http://arthas.com.cn/2016/12/17/设备像素比的实际意义/","excerpt":"设备像素比devicePixelRatio简单介绍一文专业介绍了设备像素比，摘抄精简为以下：设备像素比（devicePixelRatio）其实指的是window.devicePixelRatio, 被所有WebKit浏览器以及Opera所支持，随着显示器的发展，这个属性也慢慢登上了前端技术的舞台。window.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。","text":"设备像素比devicePixelRatio简单介绍一文专业介绍了设备像素比，摘抄精简为以下：设备像素比（devicePixelRatio）其实指的是window.devicePixelRatio, 被所有WebKit浏览器以及Opera所支持，随着显示器的发展，这个属性也慢慢登上了前端技术的舞台。window.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。 1设备像素比 = 物理像素 / 设备独立像素 设备独立像素（这是Android中的叫法，就是web开发中CSS像素）与屏幕密度(硬件)有关。可以用来辅助区分视网膜设备还是非视网膜设备。所有非视网膜屏幕的iphone在垂直的时候，宽度为320物理像素，当你使用1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 的时候，会设置视窗布局宽度（不同于视觉区域宽度，不放大显示情况下，两者大小一致）为320px, 于是，页面很自然地覆盖在屏幕上。而对于视网膜屏幕的iphone，如iphone4s, 纵向显示的时候，屏幕物理像素640像素。同样，当用户设置1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 的时候，其视区宽度并不是640像素，而是320像素，这是为了有更好的阅读体验 – 更合适的文字大小。 这样，在视网膜屏幕的iphone上，屏幕物理像素640像素，独立像素还是320像素，因此，window.devicePixelRatio等于2 从以上现象得出的结论是：UI设计师按照手机物理像素出设计稿，切图时根据其设备像素比来换算设备独立像素（CSS像素），比如视网膜手机iPhone6，物理像素750px×1334px，由于其设备像素比为2，CSS切图时需要将设计稿的所有尺寸除以2，才是正确CSS像素值。","categories":[],"tags":[{"name":"dpr","slug":"dpr","permalink":"http://arthas.com.cn/tags/dpr/"}],"keywords":[]},{"title":"关于fiex的总结","slug":"关于flex的总结","date":"2016-11-28T01:41:43.000Z","updated":"2017-09-01T14:37:15.320Z","comments":true,"path":"2016/11/28/关于flex的总结/","link":"","permalink":"http://arthas.com.cn/2016/11/28/关于flex的总结/","excerpt":"","text":"Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器的属性 flex-directionflex-direction属性决定主轴的方向（即项目的排列方向） row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 justify-contentjustify-content属性定义了项目在主轴上的对齐方式。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-itemsalign-items属性定义项目在交叉轴上如何对齐。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性 orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrinkflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 实践案例flex自适应三列布局实现 参考资料：– 阮一峰 Flex 布局教程：语法篇","categories":[],"tags":[{"name":"flex","slug":"flex","permalink":"http://arthas.com.cn/tags/flex/"}],"keywords":[]},{"title":"windows下安装Sass的正确姿势","slug":"windows下安装Sass的正确姿势","date":"2016-11-22T07:56:19.000Z","updated":"2017-09-01T14:37:05.412Z","comments":true,"path":"2016/11/22/windows下安装Sass的正确姿势/","link":"","permalink":"http://arthas.com.cn/2016/11/22/windows下安装Sass的正确姿势/","excerpt":"","text":"安装网上流传到安装方式进行了安装，修改ruby源的时候报错123Error fetching https://gems.ruby-china.org/: SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed (https://gems.ruby-china.org/specs.4.8.gz) 当时一脸懵逼，后来反应过来是SSL证书的问题。只要把镜像的https改为http即可。 安装过程安装Ruby到Ruby官网下载ruby。一路确定，安装时记得对“加入到Path”打钩。 安装完控制台输入ruby -v出现版本号表示正确安装。 修改gem源以前可以用淘宝的源 https://ruby.taobao.org/,现在此源已经不维护，最新维护的源地址为https://gems.ruby-china.org/。修改方式：1234$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/$ gem sources -lhttps://gems.ruby-china.org# 确保只有 gems.ruby-china.org 如果遇到 SSL 证书问题，你又无法解决，请直接用 http://gems.ruby-china.org 避免 SSL 的问题。 安装Sass打开控制台，根据如下命令安装Sass1gem install sass 安装完输入sass -v表示正确安装。","categories":[],"tags":[{"name":"填坑","slug":"填坑","permalink":"http://arthas.com.cn/tags/填坑/"}],"keywords":[]},{"title":"mongodb速记","slug":"mongodb速记","date":"2016-11-19T04:39:32.000Z","updated":"2017-09-01T14:39:09.275Z","comments":true,"path":"2016/11/19/mongodb速记/","link":"","permalink":"http://arthas.com.cn/2016/11/19/mongodb速记/","excerpt":"在mongodb/bin下面运行启动指令，启动mongodb服务器要带数据文件的地址，比如：windows下： 1mongod.exe --dbpath &quot;f:\\mongodb\\data","text":"在mongodb/bin下面运行启动指令，启动mongodb服务器要带数据文件的地址，比如：windows下： 1mongod.exe --dbpath &quot;f:\\mongodb\\data linux下： 123mongod --dbpath=/data/db --port=27017 (只在控制台启动)mongod --dbpath=/data/db --port=27017 --fork --syslog (以守护进程的方式启动)mongod --shutdown (结束后台命令) 控制台连接mongodb服务器： 1mongo 127.0.0.1:27017 查看当前数据库 1show dbs 使用user数据库，可以是不存在的数据库 1use user 插入一条数据 1db.user.insert(&#123;&quot;username&quot;:&quot;zhangsan&quot;,&quot;password&quot;:&quot;apple&quot;&#125;) 查看所有数据 1db.user.find(); 查看指定条件的数据 1db.user.find(&#123;&quot;username&quot;:&quot;zhangsan&quot;&#125;); 查看一条数据 1db.user.findOne() 查看一条指定条件的数据 1db.user.findOne(&#123;&quot;username&quot;:&quot;zhangsan&quot;&#125;) 更新数据只更新一条 1db.users.update(&#123;&quot;username&quot;:&quot;mohong&quot;&#125;,&#123;$set: &#123;&quot;group&quot;:&quot;writer&quot;&#125;&#125;) 更新所有满足的值1db.users.update(&#123;&quot;username&quot;:&quot;mohong&quot;&#125;,&#123;$set: &#123;&quot;group&quot;:&quot;writer&quot;&#125;&#125;,&#123;multi:true&#125;); 删除文档 123db.users.remove() 删除db.users.remove(&#123;&quot;group&quot;:&quot;design&quot;&#125;) 删除满足条件的所有文档db.users.remove(&#123;&quot;group&quot;:&quot;design&quot;&#125;， true) 只删除集合中满足条件的第一个文档 删除集合 1db.users.drop() 参考资料The MongoDB 3.2 ManualGetting Started with MongoDB (MongoDB Shell Edition)","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://arthas.com.cn/tags/mongodb/"}],"keywords":[]},{"title":"初识ReactNative","slug":"初识ReactNative","date":"2016-11-17T07:27:30.000Z","updated":"2017-09-01T14:45:44.057Z","comments":true,"path":"2016/11/17/初识ReactNative/","link":"","permalink":"http://arthas.com.cn/2016/11/17/初识ReactNative/","excerpt":"开发环境的搭建思路是：Android开发+Node开发环境+git版本控制（可选）。入坑之前需要对这两者的开发有所了解，不然过程比较懵逼。比如Android开发环境就要配置Java开发环境，即安装JDK，配置环境变量，此处JDK版本需要jdk1.8。Node开发环境要安装node，配置环境变量时一定要通过新建ANDROID_HOME和JAVA_HOME系统变量的方式指定path，不然后面会出现找不到路径的报错.node自带npm包管理工具，跟java开发中的maven差不多。","text":"开发环境的搭建思路是：Android开发+Node开发环境+git版本控制（可选）。入坑之前需要对这两者的开发有所了解，不然过程比较懵逼。比如Android开发环境就要配置Java开发环境，即安装JDK，配置环境变量，此处JDK版本需要jdk1.8。Node开发环境要安装node，配置环境变量时一定要通过新建ANDROID_HOME和JAVA_HOME系统变量的方式指定path，不然后面会出现找不到路径的报错.node自带npm包管理工具，跟java开发中的maven差不多。 根据React Native 中文网文档第一篇配合AndroidDevTools依次安装工具。 安装完Android Studio后用其下载必须的包时尝试过AndroidDevTools上面的代理，不过好像没什么作用，需要科学上网才能下载。通过运行Android Studio检测一下Android开发环境。把Android SDK的tools和platform-tools目录添加到PATH变量中，以便在终端中运行一些Android工具。上图表示Android环境运行正常。可以放心开始node开发环境的测试。 在控制台运行node -v查看node是否安装成功，运行npm -v查看npm包管理器是否正常运行。下图表示两个都OK。然后在控制台运行npm install -g react-native-cli安装react-native命令行工具。 123react-native init myAppcd myAppreact-native run-android 也可以将app发送到真机上运行，真机运行查看在设备上运行。注意，如果您的设备是MIUI系统，可能运行会失败，控制台会有安装失败的报错。解决办法是把设置--跟多设置--开发者选项--启用MIUI这一项关闭。然后就OK了。","categories":[],"tags":[{"name":"react native","slug":"react-native","permalink":"http://arthas.com.cn/tags/react-native/"}],"keywords":[]},{"title":"javascript版2048开发总结","slug":"javascript版2048开发总结","date":"2016-10-13T12:33:13.000Z","updated":"2017-09-01T14:45:32.344Z","comments":true,"path":"2016/10/13/javascript版2048开发总结/","link":"","permalink":"http://arthas.com.cn/2016/10/13/javascript版2048开发总结/","excerpt":"","text":"2048这款游戏玩起来非常简单，但是又有着神奇的吸引力，尤其是对强迫症重症患者。所以界面的设计追求了简约、轻盈，清爽的原则，此游戏的色调已经成为经典，故小方格依然采用了经典色调。背景图片选择了可无缝拼接的木质材料，以达到全屏效果且优化了请求资源的大小，其暖色格调与小方格主色调搭配，使得界面更加柔和舒适，给小格子设置了0.9的不透明度，表现出清爽轻盈，使玩家玩游戏时心情更放松。 多端适配此游戏实现了手机、平板、PC三端完美适配。为了实现适配，采用了将样式的px单位改为rem的方法。 rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。 也就是说整个游戏中的样式，除了html的font-size以px为单位外，其他的单位均为相对于html的单位，只要html的单位大小改变，其他的尺寸成倍改变，且无损质量，无突变。这样只在js中写个判断设备的屏幕尺寸的函数，然后指定不同的屏幕html的font-size使用多少的px值就可以了。 布局结构html中的静态布局首先是一个大盒子下面放了16个小格子，大盒子相对定位，小盒子的样式均为绝对定位，这样16个小盒子就聚集在大盒子内部的左上角，接着在初始化过程中通过遍历动态指定这16个小盒子的top值和left值，此时浏览器中就出现了这样的局面。 同时再创建一个二维数组（javascript本来没有二维数组的概念，可以采取数组中包含数组的方式模拟）和上面的格子一一对应来保存格子中的数据，首先通过遍历均初始化为0。 接着再创建一个函数用来继续动态生成16个小格子，用来展示上面定义的二维数组中的数字和操作游戏，还是通过遍历来指定top和left和，上面的位置吻合。判断一下，当数组中的数字为0时，宽度和高度均为0，这样就看不到小格子了，顺便把位置设在小方格的正中央，这样后面有大于0的数字了展示出来效果好看。当数组中的数字不为0时，设置上面这个小方块的宽度、高度和下面的小格子的相同，达到了覆盖的效果，同时从颜色函数中选择此时数字对应的颜色，通过element.text显示数字，再用动画展示出来。如下图所示，O表示不显示的小方块。 移动操作分别针对上移、下移、左移、右移创建四个函数，将数字不为0的小方格移动到对应的位置。以左移函数为例，函数执行过程大概是，遍历所有小方格，如果有值不为0（此处的意思是，要能移动，必须要移动存在的看得见的小方格，无法移动不存在的物体，哲学。。。），再遍历其左边的位置，有两种情况，第一种是左边为0，通过动画函数把这个小方格移动到右边值为0的位置，依次遍历；第二种情况是左边不为0，但是它俩的值相等，那么就把右边的值加到左边，同时把右边位置的值设为0，通过动画函数展示出过程。同时把这个小方块的值加在分数上，更新分数。 返回功能创建一个全局数组，每一步的状态保存一个快照（对象），通过push（）存入数组，点击还原按钮的时候读取数组数据还原上一个状态。 遇到的问题及解决方案开发的过程并非一帆风顺。 背景图不能全屏显示刚开始背景图选择的模糊的田野公路的图片，通过给body设置背景图方式加入，但是在适配移动端的过程中发现不能完全匹配，在修改为重复的情况下依然有空白，于是换了更符合设计意图的无缝木质素材，且把指定背景图的元素由body改为html，解决了有空白的问题，更符合设计意图，优化了资源大小。 相等的数字在中间有格子的情况下会合并同一行的两个格子虽然数值相等但是中间有其他小方格的话是无法合并的，这个问题的出现是因为没有考虑到做这一判断，增加了判断障碍物的函数解决了问题。 返回上一步分数没有减少点击上一步按钮，场景回退到上一个状态，但是相应的分数却没有减少，于是想到分数也是当时场景的一部分，也应该保存下来，重新设计了保存状态的对象解决了问题。 开始新游戏后能回退到上一局如果游戏刚开始就多点几次开始新游戏创建新游戏，那么每次生成的游戏数据都会保存到数组中，这样点击返回上一步的时候就会返回到上一局的游戏状态。在给创建新游戏的函数中增加了清除保存游戏状态的数组的方法后到了正常状态。 小格子中的数字达到4位数的时候显示超出范围写小格子的样式的时候是指定统一的字体大小的，没有考虑到随着数字的增大，其所占的区域也在变大。在一次玩游戏的过程中终于达到1024，此时暴露出了这个问题，于是又增加了判断语句，当数字大于四位数时相应缩小。 回顾与反思rem的适配方式web app要使用rem这一相对单位作为单位，能等比例适配所有屏幕，而且是无损的，图片文字不会糊。使用时只需要通过js检测不同的屏幕尺寸设置不同的html的font-size值就可以了。 移动端触摸事件移动端要操作游戏，需要增加触摸事件touchstart：触摸开始的时候触发touchmove：手指在屏幕上滑动的时候触发touchend：触摸结束的时候触发 而每个触摸事件都包括了三个触摸列表，每个列表里包含了对应的一系列触摸点（用来实现多点触控）：touches：当前位于屏幕上的所有手指的列表。targetTouches：位于当前DOM元素上手指的列表。changedTouches：涉及当前事件手指的列表。 每个触摸点由包含了如下触摸信息（常用）：identifier：一个数值，唯一标识触摸会话（touch session）中的当前手指。一般为从0开始的流水号（android4.1，uc）target：DOM元素，是动作所针对的目标。 pageX/pageX/clientX/clientY/screenX/screenY：一个数值，动作在屏幕上发生的位置（page包含滚动距离,client不包含滚动距离，screen则以屏幕为基准）。 radiusX/radiusY/rotationAngle：画出大约相当于手指形状的椭圆形，分别为椭圆形的两个半径和旋转角度。初步测试浏览器不支持。 Gestures 这个事件针对IOS设备上的，一个Gestures事件在两个或更多手指触摸屏幕时触发。如果任何手指你正在监听的Gesture事件(gesturestart，gesturechange，gestureend)节点上，你将收到对应的gestures事件。 Gesturestart：当一个手指已经按在屏幕上，而另一个手指又触摸在屏幕时触发。 Gesturechange：当触摸屏幕的任何一个手指的位置发生改变的时候触发。 Gestureend：当任何一个手指从屏幕上面移开时触发。 1234// 判断是否为 iPhone ：function isAppleMobile() &#123; return (navigator.platform.indexOf(&apos;iPad&apos;) != -1);&#125;;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://arthas.com.cn/tags/javascript/"}],"keywords":[]},{"title":"定制自己的Bootstrap样式","slug":"定制自己的Bootstrap样式","date":"2016-09-26T10:25:15.000Z","updated":"2017-09-01T14:45:26.870Z","comments":true,"path":"2016/09/26/定制自己的Bootstrap样式/","link":"","permalink":"http://arthas.com.cn/2016/09/26/定制自己的Bootstrap样式/","excerpt":"本文主要针对对Bootstrap有所了解，或者使用过Bootstrap的读者提供参考。官方提供了个性化定制功能 ,可以选择自己需要的组件，插件，自己设置不同模块的less变量，最后从官网下载到一份编译后的个性化bootsrap。 如果是比较复杂的项目，虽然官网开放的变量上百个，但还是不能满足业务需求，这时候就需要下载源码修改less文件，bootstrap是通过less预编译的。","text":"本文主要针对对Bootstrap有所了解，或者使用过Bootstrap的读者提供参考。官方提供了个性化定制功能 ,可以选择自己需要的组件，插件，自己设置不同模块的less变量，最后从官网下载到一份编译后的个性化bootsrap。 如果是比较复杂的项目，虽然官网开放的变量上百个，但还是不能满足业务需求，这时候就需要下载源码修改less文件，bootstrap是通过less预编译的。 lessless是一种动态样式语言。LESS 将 CSS 赋予了动态语言的特性，如 变量， 继承， 运算， 函数.使用less可以这样写css： 123456789101112131415@base: #f938ab;.box-shadow(@style, @c) when (iscolor(@c)) &#123; box-shadow: @style @c; -webkit-box-shadow: @style @c; -moz-box-shadow: @style @c;&#125;.box-shadow(@style, @alpha: 50%) when (isnumber(@alpha)) &#123; .box-shadow(@style, rgba(0, 0, 0, @alpha));&#125;.box &#123; color: saturate(@base, 5%); border-color: lighten(@base, 30%); div &#123; .box-shadow(0 0 5px, 30%) &#125;&#125; less文件需要编译器才能转化为css文件。体验less编译可以在在线less编译器中编写less语句，然后编译成css文件。gulp使用gulp-less实现编译。 变量变量允许我们单独定义一系列通用的样式，然后在需要的时候去调用。所以在做全局样式调整的时候我们可能只需要修改几行代码就可以了。例如：12345678910 // LESS@color: #4D926F;#header &#123; color: @color;&#125;h2 &#123; color: @color;&#125; 编译之后的css文件：12345678/* 生成的 CSS */#header &#123; color: #4D926F;&#125;h2 &#123; color: #4D926F;&#125; 混合混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以带参数地调用，就像使用函数一样。1234567891011121314// LESS.rounded-corners (@radius: 5px) &#123; border-radius: @radius; -webkit-border-radius: @radius; -moz-border-radius: @radius;&#125;#header &#123; .rounded-corners;&#125;#footer &#123; .rounded-corners(10px);&#125; 编译后的css文件123456789101112* 生成的 CSS */#header &#123; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px;&#125;#footer &#123; border-radius: 10px; -webkit-border-radius: 10px; -moz-border-radius: 10px;&#125; 嵌套规则我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。12345678910111213// LESS#header &#123; h1 &#123; font-size: 26px; font-weight: bold; &#125; p &#123; font-size: 12px; a &#123; text-decoration: none; &amp;:hover &#123; border-width: 1px &#125; &#125; &#125;&#125; 编译后的css文件：123456789101112131415/* 生成的 CSS */#header h1 &#123; font-size: 26px; font-weight: bold;&#125;#header p &#123; font-size: 12px;&#125;#header p a &#123; text-decoration: none;&#125;#header p a:hover &#123; border-width: 1px;&#125; 函数 &amp; 运算运算提供了加，减，乘，除操作；我们可以做属性值和颜色的运算，这样就可以实现属性值之间的复杂关系。LESS中的函数一一映射了JavaScript代码，如果你愿意的话可以操作属性值。123456789101112131415// LESS@the-border: 1px;@base-color: #111;@red: #842210;#header &#123; color: @base-color * 3; border-left: @the-border; border-right: @the-border * 2;&#125;#footer &#123; color: @base-color + #003300; border-color: desaturate(@red, 10%);&#125; 编译后的css文件：1234567891011/* 生成的 CSS */#header &#123; color: #333; border-left: 1px; border-right: 2px;&#125;#footer &#123; color: #114411; border-color: #7d2717;&#125; bootstrap源码 Bootstrap 插件全部依赖 jQuery请注意，Bootstrap 的所有 JavaScript 插件都依赖 jQuery，因此 jQuery 必须在 Bootstrap 之前引入，就像在基本模版中所展示的一样。在 bower.json 文件中 列出了 Bootstrap 所支持的 jQuery 版本。 下载源码bootsrap源码托管于github，可以通过git命令克隆仓库：1git clone https://github.com/twbs/bootstrap.git 还可以通过包管理工具bower安装：1bower install bootsrap 运行次命令后，bower会下载最新版的bootsrap源码包到项目中。 源码解读Bootstrap 源码包含了预先编译的 CSS、JavaScript 和图标字体文件，并且还有 LESS、JavaScript 和文档的源码。具体来说，主要文件组织结构如下12345678910bootstrap/├── less/├── js/├── fonts/├── dist/│ ├── css/│ ├── js/│ └── fonts/└── docs/ └── examples/ less/、js/ 和 fonts/ 目录分别包含了 CSS、JS 和字体图标的源码。dist/ 目录包含了编译后的bootsrap的css文件。docs/ 包含了所有文档的源码文件，examples/ 目录是 Bootstrap 官方提供的实例工程。除了这些，其他文件还包含 Bootstrap 安装包的定义文件、许可证文件和编译脚本等。 bootstrap/less目录下的文件均为.less文件，是bootsrap样式的主要代码，不同的文件根据功能及性质命名。 bootstrap.less:这个是核心文件。它用来引入其他文件，最终由你来编译它。 reset.less:初始化文件，始终是最先引入的文件。 utilities.less这个文件总是最后引入，你可以把想要覆盖的类写到这里。 模块化修改为了让修改的内容和原始文件分离开，需要引进模块的方式，这样的好处是如果bootstrap升级的时候，也不影响自定义后的样式文件。由于less文件可以相互引入，因此很容易实现了模块化在bootsrap文件外边平级创建一个custom文件夹，并创建以下文件 custom-variables.less:我从Bootstrap源码中复制了一份variables.less并在这份拷贝中修改变量。 custom-other.less:这个文件中包含了那些无法定义成变量的自定义内容。 custom-bootstrap.less这是新的「核心」文件。我们将把它编译成CSS。与原始的 LESS文件一样，它使用下面的命令来引入上面那两个自定义文件： 1234@import &quot;../bootstrap/less/bootstrap.less&quot;;@import &quot;custom-variables.less&quot;;@import &quot;custom-other.less&quot;;@import &quot;../bootstrap/less/utilities.less&quot;; 这样等bootsrap版本升级的时候也能轻松实现升级。 可视化修改最后提供两个可视化修改bootsrap变量的网站bootswatchr 通过修改变量值实现。stylebootstrap 通过组件化组织内容。 参考资料：http://www.bootcss.com/p/lesscss/#docshttp://www.w3cplus.com/css/customizing-bootstrap.htmlThomas Park 《Customizing Bootstrap》","categories":[],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://arthas.com.cn/tags/bootstrap/"}],"keywords":[]},{"title":"实现类似饿了么网站标题栏的交互","slug":"实现类似饿了么网站标题栏的交互","date":"2016-08-24T14:30:00.000Z","updated":"2016-09-12T16:11:57.743Z","comments":true,"path":"2016/08/24/实现类似饿了么网站标题栏的交互/","link":"","permalink":"http://arthas.com.cn/2016/08/24/实现类似饿了么网站标题栏的交互/","excerpt":"","text":"用到了PageVisibility API。PageVisibility API用于判断页面是否处于浏览器的当前窗口，即是否可见。 属性这个API部署在document对象上，提供以下两个属性。 document.hidden：返回一个布尔值，表示当前是否被隐藏 document.visibilityState：表示页面当前的状态，可以取三个值，分别是visibile（页面可见）、hidden（页面不可见）、prerender（页面正处于渲染之中，不可见）。 VisibilityChange事件当页面的可见状态发生变化时，会触发VisibilityChange事件（带有浏览器前缀）。123document.addEventListener(&quot;visibilitychange&quot;, function() &#123; console.log( document.visibilityState );&#125;); 饿了么网站的页面标题交互效果： 下面是实现页面切换后标题改变的Demo: 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;网页标题处&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var title = document.title; //保存原网页的名称 document.addEventListener(&quot;visibilitychange&quot;, function() &#123; console.log(document.visibilityState); if (document.visibilityState == &apos;hidden&apos; ) &#123; document.title = &apos;不要离开我！！！&apos;; &#125; else if (document.visibilityState == &apos;visible&apos;) &#123; console.log(title); document.title = title; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现的效果： 参考链接阮一峰：Page Visibility API","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://arthas.com.cn/tags/前端/"}],"keywords":[]},{"title":"Hexo修改了样式部署后无效果解决办法","slug":"Hexo修改了样式部署后无效果解决办法","date":"2016-07-30T05:44:11.000Z","updated":"2017-09-01T14:47:40.313Z","comments":true,"path":"2016/07/30/Hexo修改了样式部署后无效果解决办法/","link":"","permalink":"http://arthas.com.cn/2016/07/30/Hexo修改了样式部署后无效果解决办法/","excerpt":"修改完Hexo的样式后本地预览已经显示正常了，hexo deploy后却还是之前的样式，百度一圈之后明白其原因是之前生成部署缓存文件导致的，得到有效的解决办法：1hexo clean 此指令会清楚之前的部署缓存文件，然后在hexo g，hexo d，刷新页面，站点已更新为最新的样式。","text":"修改完Hexo的样式后本地预览已经显示正常了，hexo deploy后却还是之前的样式，百度一圈之后明白其原因是之前生成部署缓存文件导致的，得到有效的解决办法：1hexo clean 此指令会清楚之前的部署缓存文件，然后在hexo g，hexo d，刷新页面，站点已更新为最新的样式。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://arthas.com.cn/tags/Hexo/"}],"keywords":[]},{"title":"彻底解决mysql不能输入中文的问题","slug":"彻底解决mysql不能输入中文的问题","date":"2016-07-16T13:53:30.000Z","updated":"2017-09-02T01:50:35.520Z","comments":true,"path":"2016/07/16/彻底解决mysql不能输入中文的问题/","link":"","permalink":"http://arthas.com.cn/2016/07/16/彻底解决mysql不能输入中文的问题/","excerpt":"用struts2写了一个页面表单提交数据，数据库为MySQL。提交的时候出现了如下报错：1234java.lang.RuntimeException: java.sql.SQLException: Incorrect string value: &apos;\\xE5\\x90\\x83\\xE9\\xA5\\xAD...&apos; for column &apos;hobby&apos; at row 1 Query: insert into students (username,password,gender,hobby,birthday,email,grade) values (?,?,?,?,?,?,?) Parameters: [Ttt, ttt, male, 吃饭,睡觉, null, , 0] at com.itheima.dao.impl.StudentDaoImpl.save(StudentDaoImpl.java:21) at com.itheima.service.impl.BusinessServiceImpl.registStudent(BusinessServiceImpl.java:11) ...... 当把表单内容全部修改为字母时，提交成功。然后在mysql中\\s，查看到如下信息：","text":"用struts2写了一个页面表单提交数据，数据库为MySQL。提交的时候出现了如下报错：1234java.lang.RuntimeException: java.sql.SQLException: Incorrect string value: &apos;\\xE5\\x90\\x83\\xE9\\xA5\\xAD...&apos; for column &apos;hobby&apos; at row 1 Query: insert into students (username,password,gender,hobby,birthday,email,grade) values (?,?,?,?,?,?,?) Parameters: [Ttt, ttt, male, 吃饭,睡觉, null, , 0] at com.itheima.dao.impl.StudentDaoImpl.save(StudentDaoImpl.java:21) at com.itheima.service.impl.BusinessServiceImpl.registStudent(BusinessServiceImpl.java:11) ...... 当把表单内容全部修改为字母时，提交成功。然后在mysql中\\s，查看到如下信息： 1234567891011121314Connection id: 2Current database:Current user: root@localhostSSL: Not in useUsing delimiter: ;Server version: 5.6.11 MySQL Community Server (GPL)Protocol version: 10Connection: localhost via TCP/IPServer characterset: latin1Db characterset: latin1Client characterset: gbkConn. characterset: gbkTCP port: 3306Uptime: 6 min 34 sec 根据报错查找到原因：mysql编码问题。最终解决办法：找到mysql配置文件my.ini，在[mysqld]中添加如下语句：1character-set-server = utf8 继续，找到[mysql]，添加如下语句：1default-character-set = utf8 原因解释：数据库的字符集是什么，表的字符集就是什么，同样MySQL服务器有自己的字符集，他们的优先级从大到小是这样的，MySQL服务器&gt;数据库&gt;表，意思就是，如果不指定数据库的字符集，在创建数据库的时候它会与MySQL服务器的字符集保持一致。通过\\s查看msql服务器的基本信息，注意以下语句： 1234Server characterset: utf8 //MySQL服务器字符集Db characterset: utf8 //数据库字符集Client characterset: utf8 //客户端字符集Conn. characterset: utf8 //客户端连接字符集 通过show create database test查看数据库的字符集，通过show create table user查看表的字符集。 如果在mysql未正确指定字符集的情况下已经创建了某个表，然后又修改了mysql服务器的字符集，存入的数据将会乱码，解决办法是修改此表的字符集和mysql服务器的一致，即utf8，通过以下命令修改 1ALTER TABLE tbl_name CONVERT TO CHARACTER SET charset_name; tbl_name：表名charset_name：字符集名 只要遵循客户端字符集与数据库字符集统一即可解决乱码或者无法输入中文的问题。设置mysql服务器的字符集为utf8，jdbc连接mysql的时候发送字符集为utf-8，客户端show的时候也为utf-8，就不会出现乱码问题了。","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://arthas.com.cn/tags/mysql/"}],"keywords":[]},{"title":"Java web中的常用类名词解释","slug":"Java-web中的常用类名词解释","date":"2016-07-10T02:47:23.000Z","updated":"2017-09-01T14:49:19.482Z","comments":true,"path":"2016/07/10/Java-web中的常用类名词解释/","link":"","permalink":"http://arthas.com.cn/2016/07/10/Java-web中的常用类名词解释/","excerpt":"DBCP（DataBase Connection Pool）数据库连接池。是 apache 上的一个 java 连接池项目，也是 tomcat 使用的连接池组件。单独使用dbcp需要2个包：commons-dbcp.jar,commons-pool.jar由于建立数据库连接是一个非常耗时耗资源的行为，所以通过连接池预先同数据库建立一些连接，放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完后再放回去。","text":"DBCP（DataBase Connection Pool）数据库连接池。是 apache 上的一个 java 连接池项目，也是 tomcat 使用的连接池组件。单独使用dbcp需要2个包：commons-dbcp.jar,commons-pool.jar由于建立数据库连接是一个非常耗时耗资源的行为，所以通过连接池预先同数据库建立一些连接，放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完后再放回去。 Dbutils是Apache组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程序的开发，同时也不会影响程序的性能。传统操作数据库的类指的是JDBC（java database connectivity：java数据库连接，java的数据库操作的基础API。）。 JSTLJSTL（JSP Standard Tag Library，JSP标准标签库)是一个不断完善的开放源代码的JSP标签库，是由apache的jakarta小组来维护的。JSTL只能运行在支持JSP1.2和Servlet2.3规范的容器上，如tomcat 4.x。在JSP 2.0中也是作为标准支持的。","categories":[],"tags":[{"name":"java web","slug":"java-web","permalink":"http://arthas.com.cn/tags/java-web/"}],"keywords":[]},{"title":"Linux下后台运行jar文件","slug":"Linux下后台运行jar文件","date":"2016-07-04T02:34:58.000Z","updated":"2017-09-01T14:54:05.885Z","comments":true,"path":"2016/07/04/Linux下后台运行jar文件/","link":"","permalink":"http://arthas.com.cn/2016/07/04/Linux下后台运行jar文件/","excerpt":"当我们把java程序打成jar包后，放到linux上通过putty或其它终端执行的时候，如果按照：java -jar xxxx.jar执行，当我们退出putty或终端的时候，xxxx.jar这个程序也会停止。为了保证程序能够一直运行，应该改为这样运行： java -jar xxx.jar &amp;命令，则程序会在后台一直运行，值得注意的是，此时程序控制台输出会被转移到nohup.out文件中，这个nohup.out文件的位置就在jar包的当前文件夹内。","text":"当我们把java程序打成jar包后，放到linux上通过putty或其它终端执行的时候，如果按照：java -jar xxxx.jar执行，当我们退出putty或终端的时候，xxxx.jar这个程序也会停止。为了保证程序能够一直运行，应该改为这样运行： java -jar xxx.jar &amp;命令，则程序会在后台一直运行，值得注意的是，此时程序控制台输出会被转移到nohup.out文件中，这个nohup.out文件的位置就在jar包的当前文件夹内。 但是有时候在这一步会有问题，当把终端关闭后，进程会自动被关闭，察看nohup.out可以看到在关闭终端瞬间服务自动关闭。有个操作终端时的细节：当shell中提示了nohup成功后还需要按终端上键盘任意键退回到shell输入命令窗口，然后通过在shell中输入exit来退出终端；而我是每次在nohup执行成功后直接点关闭程序按钮关闭终端。所以这时候会断掉该命令所对应的session，导致nohup对应的进程被通知需要一起shutdown。 当需要关闭这个后台运行的jar文件时，执行以下命令查看目前的所有进程：ps -A找到对应的pid，然后执行以下命令杀死进程：kill -9 pid","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://arthas.com.cn/tags/linux/"}],"keywords":[]},{"title":"解决每次向github提交要输入用户名和密码问题","slug":"解决每次向github提交要输入用户名和密码问题","date":"2016-05-24T02:19:23.000Z","updated":"2017-09-01T14:54:35.950Z","comments":true,"path":"2016/05/24/解决每次向github提交要输入用户名和密码问题/","link":"","permalink":"http://arthas.com.cn/2016/05/24/解决每次向github提交要输入用户名和密码问题/","excerpt":"通过SSH文件的验证方式可以解决每次向github提交都要输入用户名和密码的问题 检查是否存在SSH keys在生成你的SSH key之前，先检查你的电脑上是否存在SSH keys","text":"通过SSH文件的验证方式可以解决每次向github提交都要输入用户名和密码的问题 检查是否存在SSH keys在生成你的SSH key之前，先检查你的电脑上是否存在SSH keys 1ls -al ~/.ssh 如果检测结果是没有，可在后续步骤中生成如果检测结果是有，可直接用于Github配置 生成新的SSH keys 并且添加到ssh-agent中 生成新的SSH keys 1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 出现选择文件路径，用默认路径就可以，按回车 1Enter a file in which to save the key (/Users/you/.ssh/id_rsa): 输入密码时一般没必要输入，直接回车 1Enter passphrase (empty for no passphrase): 重复输入时继续按回车 添加SSH keys到ssh-agent中如果你使用了其他生成工具生成了新的SSH key，就需要设置此代理 1ssh-add ~/.ssh/id_rsa 把SSH key 拷贝到Github网站在电脑中找到刚生成的SSH key ，默认路径为C:\\Users\\mohong\\.ssh，用编辑器打开id_rsa.pub文件，复制内容。 登录Github，找到Setting--SSH and GPG keys，点击创建新的SSH,把内容粘贴在上面，然后起个名字便于多台设备绑定时分辨出设备。 测试SSH连接 1ssh -T git@github.com 第一次使用时，你将会收到以下提示，输入yes即可。123The authenticity of host &apos;github.com (192.30.252.1)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 123The authenticity of host &apos;github.com (192.30.252.1)&apos; can&apos;t be established.RSA key fingerprint is nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? 最后如果看到以下内容，表示绑定成功12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 参考资料","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://arthas.com.cn/tags/git/"}],"keywords":[]},{"title":"Java学习中遇到的困惑","slug":"学习Java过程中遇到的困惑","date":"2016-04-29T09:34:03.000Z","updated":"2017-09-01T15:02:08.982Z","comments":true,"path":"2016/04/29/学习Java过程中遇到的困惑/","link":"","permalink":"http://arthas.com.cn/2016/04/29/学习Java过程中遇到的困惑/","excerpt":"继承（extends）与实现（implements）父类的方法中可以有抽象（abstract）方法，也可以没有抽象方法。当有抽象方法时，这个类就叫做抽象类。假设有一个类的方法既有抽象方法，又有普通方法，如果某子类继承（extends）了该类，且该子类需要创建对象，就必须要实现父类中的所有抽象方法才可创建。Java是单继承的。接口有两个特点：","text":"继承（extends）与实现（implements）父类的方法中可以有抽象（abstract）方法，也可以没有抽象方法。当有抽象方法时，这个类就叫做抽象类。假设有一个类的方法既有抽象方法，又有普通方法，如果某子类继承（extends）了该类，且该子类需要创建对象，就必须要实现父类中的所有抽象方法才可创建。Java是单继承的。接口有两个特点： 接口中所有的属性 默认的修饰符是public static final 接口中所有的方法 默认的修饰符是public abstract所以，实现（implements）接口的时候，必须要把接口中的所有方法都实现，因为接口中定义的所有方法都不能有方法体，默认都是abstract修饰的。一个类可以实现多个接口。有抽象函数的不一定是抽象类，也可以是接口类。 由于接口中的方法默认都是抽象的，所以不能被实例化。如果实现类中要访问接口中的成员，不能使用super关键字。因为两者之间没有显式的继承关系，况且接口中的成员成员属性是静态的。可以使用接口名直接访问。类与类之间的关系是继承（extends）类与接口之间的关系是实现（implements） 接口利用接口可以制定一套规则（标准），避免开发过程中对相同功能的方法起不同的名字。接口可以扩展功能，弥补java单继承中的缺点 例如我定义了一个接口，但是我在继承这个接口的类中还要写接口的实现方法，那我不如直接就在这个类中写实现方法岂不是更便捷，还省去了定义接口？ 接口就是个招牌。比如说你今年放假出去杭州旅游，玩了一上午，你也有点饿了，突然看到前面有个店子，上面挂着KFC，然后你就知道今天中饭有着落了。KFC就是接口，我们看到了这个接口，就知道这个店会卖炸鸡腿（实现接口）。那么为神马我们要去定义一个接口涅，这个店可以直接卖炸鸡腿啊（直接写实现方法），是的，这个店可以直接卖炸鸡腿，但没有挂KFC的招牌，我们就不能直接简单粗暴的冲进去叫服务员给两个炸鸡腿了。要么，我们就要进去问，你这里卖不卖炸鸡腿啊，卖不卖汉堡啊，卖不卖圣代啊（这就是反射）。很显然，这样一家家的问实在是非常麻烦（反射性能很差）。要么，我们就要记住，中山路108号卖炸鸡，黄山路45号卖炸鸡（硬编码），很显然这样我们要记住的很多很多东西（代码量剧增），而且，如果有新的店卖炸鸡腿，我们也不可能知道（不利于扩展）。知乎用户对接口的解释 关于多态多态弊端，只能使用父类引用指向父类成员，指向子类成员是会运行报错。非多态对象强制转换成子类型，引用子类型的特有方法时运行报错，报错信息为：java.lang.ClassCastException instanceof equals ＂＝＂ containsAll()instanceof：判断某个对象是不是由某个类创建的，例如：123if(obj instanceof A)&#123; // 如果obj对象属于A类 System.out.print(&quot;Hello Again! World!!!&quot;);&#125; equals：比较的是对象的内存地址值，返回true或者false。 “=”用于数值比较 containsAll() 判断集合中是否包含指定集合","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://arthas.com.cn/tags/java/"}],"keywords":[]},{"title":"MySQL基础","slug":"MySQL基础","date":"2016-04-26T03:21:16.000Z","updated":"2017-09-01T15:03:11.571Z","comments":true,"path":"2016/04/26/MySQL基础/","link":"","permalink":"http://arthas.com.cn/2016/04/26/MySQL基础/","excerpt":"Structured Query Language 结构化查询语言, 关系型数据库，由标准和扩展部分组成","text":"Structured Query Language 结构化查询语言, 关系型数据库，由标准和扩展部分组成 SQL语句的组成 DQL 数据查询语言 DML 数据操作语言 DDL 数据定义语言 DCL 数据控制语言 TPL 事务处理语言 CCL 指针控制语言 常用数据库 Oracle DB2 MySQL MySQL的安装与配置大小写问题：mysql在windows系统中不区分大小写，但在其他系统中严格区分大小写。验证是否安装配置成功：mysql -u root -p （Hibernate）Java类和表结构对应的Java对象和表中的一条记录是对应的 DDL：数据定义语言作用：用于描述数据库中要存储的现实世界实体的语言。即创建数据库和表的结构常用关键字：CREATE , ALTER , DROP , TRUNCATE 库操作显示所有的数据库：show databases; 创建一个名为mydb1的数据库：create database mydb1; 查看数据库的创建细节，可以看到使用的字符集show create database mydb1; 创建一个使用gbk字符集的mydb2数据库：create database mydb2 character set gbk; 删除前面创建的mydb2数据库：drop database mydb2; 把mydb1的字符集修改为utf8;alter database mydb1 character set utf8; 表操作选择数据库use mydb1; 显示当前选择的数据库select database(); 创建一个员工表：123456789create table employee( id int, name varchar(100), gender varchar(10), birthday date, job varchar(100), salary float(8,2), resume text); 查看库中的所有表格show tables; 查看表的结构desc employee; 查看表的创建细节show create table employee; 添加一个image列alter table employee add image blob; 修改job列的长度为60alter table employee modify job varchar(60); 删除image列alter table employee drop image; 表名改为userrename table employee to user; 修改表的字符集为utf8alter table user character set utf8; 修改列名name为usernamealter table user change name username varchar(100); DML：数据操作语言作用：向数据库中插入、删除、修改数据常用关键字：insert ,update,delete注意： mysql中，字符串或者日期要包含在单引号中 空值的表示为：null 使用insert语句向表中插入三个员工的信息 insert into user values (1,&#39;tom&#39;,&#39;female&#39;,&#39;1992-3-9&#39;,&#39;CTO&#39;,&#39;1000&#39;,&#39;developer&#39;); insert into user (id,username,gender,birthday,job,salary,resume) values (2,&#39;jack&#39;,&#39;male&#39;,&#39;1993-3-9&#39;,&#39;CTO&#39;,&#39;2000&#39;,&#39;developer&#39;); insert into user (id,username,gender,birthday,job,salary,resume) values (3,&#39;Lili&#39;,&#39;female&#39;,&#39;1993-3-9&#39;,&#39;CTO&#39;,&#39;2000&#39;,&#39;developer&#39;); 12345678910111213mysql&gt; show variables like &apos;character%&apos;;+--------------------------+--------------------------------+| Variable_name | Value |+--------------------------+--------------------------------+| character_set_client | gbk 客户端使用的编码| character_set_connection | gbk 数据库连接时使用的编码| character_set_database | utf8 数据库使用的编码| character_set_filesystem | binary | character_set_results | gbk 查询结果集使用的编码| character_set_server | latin1 服务器使用的编码| character_set_system | utf8 系统使用的编码| character_sets_dir | E:\\xampp\\mysql\\share\\charsets\\ |+--------------------------+--------------------------------+ 告知服务器客户端使用的编码：set character_set_client=gbk; 告知服务器返回的结果集使用gbk：set character_set_results=gbk 查看表中的所有记录select * from user; 将所有员工的薪水修改为3000：update user set salary=3000; 将姓名为“tom”的员工薪水改为2500：update user set salary=2500 where username=&#39;tom&#39;; 将姓名为”jack” 的员工薪水改为3200，job改为front-end：update user set salary=4000,job=&#39;font-end&#39; where username=&#39;jack&#39;; 将Lili的薪水在原有的基础上增加1000：update user set salary=salary+1000 where username=&#39;Lili&#39;; 删除表中用户名为Lili的记录：delete from user where username=&#39;Lili&#39;; 删除表中所有记录：delete from user; 使用truncate删除表中记录(摧毁整张表格，重新建立表结构)truncate table user; DQL 数据查询语言Date Query Language作用：查询数据，返回结果集常用关键字：select 查询所有学生的信息select * from student; 查询表中所有学生的姓名和对应的英语成绩select name,english from student; 过滤表中重复的数据select distinct english from student; 给所有学生数学分数加上10分特长分select name,math+10 from student; 统计每个学生的总分select name,chinese+english+math from student; 使用别名表示学生分数select name as 姓名,chinese+english+math 总分 from student; 查询id=1的学生信息select * from student where id=1; 查询英语分数在80-90之间的学生信息select * from student where english between 80 and 90; 查询数学成绩为89，90,91的学生信息select * from student where math in (89,90,91); 查询姓李的学生信息select * from student where name like &#39;李%&#39;; 查询数学成绩大于80，语文成绩大于80的学生select * from student where math&gt;80 and chinese&gt;80; 对数学成绩排序输出select name,math from student order by math; 对总分排序从高到低倒序输出select name as 姓名,chinese+english+math 总分 from student order by 总分 desc; 数据完整性数据完整性是为了保证插入到数据中的数据是正确的，它放防止了用户可能的输入错误。 实体（行）完整性规定表的一行（即每一条记录）在表中是唯一的实体。通过定义主键约束来实现主键：primary key （不能为null,且唯一） 逻辑主键：比如ID，不代表实际的业务意义，只是用来标识唯一的一条记录（推荐使用） 业务主键：比如username作为主键实现方式1：1234create table t1( id int primary key, name varchar(100) ); 实现方式2：可以定义联合主键12345create table t2( id int, name varchar(100), primary key (id)); 实现方式3：（推荐）12345create table t3( id int, name varchar(100));alter table t3 add primary key (id); 主键自增（Oracle没有）1234create table t4( id int primary key auto_increment, name varchar(100)); 域（列）完整性指数据库表的列（即字段）必须符合某种特定的数据类型或约束数据类型长度非空约束（not null）唯一约束（unique） 12345create table t5( username varchar(100) not null unique, gender varchar(100), phonenumber varchar(100)); 参照完整性（多表）外键约束多表设计：一对多，多对多，一对一一对多： 12345678910111213create table customers( id int, name varchar(100), address varchar(255));create table orders( id int primary key, order_num varchar(100), price float(8,2), status int, customer_id int, constraint customer_id_fk foreign key(customer_id) references customers(id)); 多表查询链接查询 交叉链接 （隐式查询，不使用关键字）：select * from customers,orders; 内链接：select * from customers c,orders o where c.id=o.customer_id; 外链接：左外：返回符合链接条件的记录，同时返回左表中不满足链接条件的剩余记录右外： 几个简单的查询 嵌套查询 子查询的语句放到小括号之内。 联合查询 报表查询 分组统计统计一个班共有多少学生？select count(*) from student; 统计数学成绩大于90分的学生共有多少个select count(*) from student where math&gt;90; 统计一个班的数学总成绩select sum(math) from student ; 注意：可以使用反引号把关键字引起来，当做普通字符串对待","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://arthas.com.cn/tags/mysql/"}],"keywords":[]},{"title":"JavaScript正则表达式","slug":"JavaScript正则表达式","date":"2016-04-11T03:56:02.000Z","updated":"2018-01-15T08:35:48.499Z","comments":true,"path":"2016/04/11/JavaScript正则表达式/","link":"","permalink":"http://arthas.com.cn/2016/04/11/JavaScript正则表达式/","excerpt":"正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法。本章介绍 JavaScript正则表达式。","text":"正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法。本章介绍 JavaScript正则表达式。 预定义字符正则表达式为我们提供了几个常用的预定义类来匹配常见的字符,任何预定义字符么有加上数量词之前都只能匹配一个字符。 字符 等价类 含义 . [^\\n\\r] 除了回车符和换行符之外的所有字符 \\d [0-9] 数字字符 \\D [^0-9] 非数字字符 \\s [ \\t\\n\\x0B\\f\\r] 空白符 \\S [^ \\t\\n\\x0B\\f\\r] 非空白符 \\w [a-zA-Z_0-9] 单词字符(字母、数字、下划线) \\W [^a-zA-Z_0-9] 非单词字符 1eg: ab+数字+任意字符 --- ab\\d. 边界正则表达式还提供了几个常用的边界匹配字符 字符 含义 ^ 以xx开头 $ 以xx结尾 \\b 单词边界，指[a-zA-Z_0-9]之外的字符 \\B 非单词边界 量词 字符 含义 ？ 出现零次或一次（最多出现一次） + 出现一次或多次（至少出现一次） * 出现零次或多次（任意次） {n} 出现n次 {n, m} 出现n到m次 {n, } 至少出现n次 \\w+\\b Byron 匹配 单词＋边界＋Byron 12345(/\\w+\\b Byron/).test(&apos;Hi Byron&apos;); //true(/\\w+\\b Byron/).test(&apos;Welcome Byron&apos;); //true(/\\w+\\b Byron/).test(&apos;HiByron&apos;); //false \\d+\\.\\d{1,3} 匹配三位小数的数字 贪婪模式与非贪婪模式看了上面介绍的量词，也许爱思考的同学会想到关于匹配原则的一些问题，比如{3,5}这个量词，要是在句子中出现了十次，那么他是每次匹配三个还是五个，反正3、4、5都满足3～5的条件，量词在默认下是尽可能多的匹配的，也就是大家常说的贪婪模式 1&apos;123456789&apos;.match(/\\d&#123;3,5&#125;/g); //[&quot;12345&quot;, &quot;6789&quot;] 既然有贪婪模式，那么肯定会有非贪婪模式，让正则表达式尽可能少的匹配，也就是说一旦成功匹配不不再继续尝试，做法很简单，在量词后加上 ? 即可 1&apos;123456789&apos;.match(/\\d&#123;3,5&#125;?/g); //[&quot;123&quot;, &quot;456&quot;, &quot;789&quot;] 分组有时候我们希望使用量词的时候匹配多个字符，而不是像上面例子只是匹配一个，比如希望匹配Byron出现20次的字符串，我们如果写成 Byron{20} 的话匹配的是Byro＋n出现20次，怎么把Byron作为一个整体呢？使用()就可以达到次目的，我们称为分组 1(Byron)&#123;20&#125; 如果希望匹配Byron或Casper出现20次该怎么办呢？可以使用字符 ｜ 达到或的功效 1(Byron|Casper)&#123;20&#125; 我们看到图中有个＃1的东东，那是什么？使用分组的正则表达式会把匹配项也放到分组中，默认就是按数字编号分发的，各异根据编号获得捕获的分组内容，这个在一些希望具体操作第几个匹配项的函数中很有用 1(Byron).(ok) 如果有分组嵌套的情况，外面的组的编号靠前 1((^|%&gt;)[^\\t]*) 有时候我们不希望捕获某些分组，只需要在分组内加上 ?: 就可以了，着并不意味着该分组内容不属于正则表达式，只是不会给这个分组加编号了而已 1(?:Byron).(ok) 前瞻 表达式 含义 exp1(?=exp2) 匹配后面是exp2的exp1 exp1(?!exp2) 匹配后面不是exp2的exp1 举个例子： good(?=Byron) 123(/good(?=Byron)/).exec(&apos;goodByron123&apos;); //[&apos;good&apos;](/good(?=Byron)/).exec(&apos;goodCasper123&apos;); //null(/bad(?=Byron)/).exec(&apos;goodCasper123&apos;);//null 通过上面例子可以看出 exp1(?=exp2) 表达式会匹配exp1表达式，但只有其后面内容是exp2的时候才会匹配，也就是两个条件，exp1(?!exp2) 比较类似 good(?!Byron) 123(/good(?!Byron)/).exec(&apos;goodByron123&apos;); //null(/good(?!Byron)/).exec(&apos;goodCasper123&apos;); //[&apos;good&apos;](/bad(?!Byron)/).exec(&apos;goodCasper123&apos;);//null 参考资料 JavaScript 正则表达式上——基本语法 司徒正美 javascript正则表达式 https://regexper.com/ 15个常用的javaScript正则表达式","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://arthas.com.cn/tags/JavaScript/"}],"keywords":[]},{"title":"什么是webView","slug":"什么是webview","date":"2016-04-05T09:01:11.000Z","updated":"2017-09-01T15:09:12.868Z","comments":true,"path":"2016/04/05/什么是webview/","link":"","permalink":"http://arthas.com.cn/2016/04/05/什么是webview/","excerpt":"在Android手机中内置了一款高性能webkit内核浏览器，在SDK中封装为一个叫做WebView（网络视图）的组件。Android4.4的内核是chrome内核，Android4.4以下是Android webkit内核。A View that displays web pages. This class is the basis upon which you can roll your own web browser or simply display some online content within your Activity. It uses the WebKit rendering engine to display web pages and includes methods to navigate forward and backward through a history, zoom in and out, perform text searches and more.","text":"在Android手机中内置了一款高性能webkit内核浏览器，在SDK中封装为一个叫做WebView（网络视图）的组件。Android4.4的内核是chrome内核，Android4.4以下是Android webkit内核。A View that displays web pages. This class is the basis upon which you can roll your own web browser or simply display some online content within your Activity. It uses the WebKit rendering engine to display web pages and includes methods to navigate forward and backward through a history, zoom in and out, perform text searches and more. 事件webView加载时有3个事件： loading 开始载入页面时触发 titleupdate 载入过程中title已经解析并赋予新值，则触发titleupdate loaded 载入完毕触发loaded 作用利用webView的这种方式在有些时候UI布局就可以转成相应的html代码编写了，在UI和视觉效果上就会节省很多时间，而且可以和js交互，为前端打开了一扇大门，于是乎，前端人员华丽丽的开始了移动应用开发。 开发（Hbuilder） webView是调用原生界面的H5+对象 单个webView只承载单个页面的DOM，多个webView可以组合，套嵌 页面之间会相互遮挡，所以大小很重要 要想使界面流畅，就要合理组合使用webView","categories":[],"tags":[{"name":"webwiew","slug":"webwiew","permalink":"http://arthas.com.cn/tags/webwiew/"}],"keywords":[]},{"title":"CSS中的绝对定位和相对定位","slug":"CSS中的绝对定位和相对定位","date":"2016-03-27T13:25:06.000Z","updated":"2017-09-01T15:08:56.998Z","comments":true,"path":"2016/03/27/CSS中的绝对定位和相对定位/","link":"","permalink":"http://arthas.com.cn/2016/03/27/CSS中的绝对定位和相对定位/","excerpt":"CSS中的定位方式有相对定位(relative)和绝对定位(absolute)","text":"CSS中的定位方式有相对定位(relative)和绝对定位(absolute) 相对定位：position: relative 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或者水平位置，让这个元素“相对于”它的起点移动。在使用相对定位时，无论是否移动，元素任然占据原来的空间，因此，移动元素会导致它覆盖其他框。 例如： 12345#div2 &#123; position: relative; left: 20px; top: 20px;&#125; 绝对定位：position:absolute 相对定位实际上被看做普通流定位模型的一部分，因为元素的位置是相对于它在普通流中的位置的。与之相反，绝对定位使元素的位置与文档流无关，因此不占据空间。绝对定位的元素的位置是相对于距离它最近的那个已定位的祖先元素确定的。 例如： 12345#div2 &#123; position: absolute; left: 20px; top: 20px;&#125; 因为绝对定位的框与文档流无关，所以它们可以覆盖页面上的其他元素，可以通过设置z-index属性来控制这些框的叠放次序。z-index的值越高，框在栈中的位置就越高。 如果要相对于相对定位的框的右边或者底部设置绝对定位的框的位置，那么需要确保相对定位的框已经设置了尺寸。如果没有，那么IE会错误地相对于画布定位这个框。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://arthas.com.cn/tags/css/"}],"keywords":[]},{"title":"Linux学习笔记","slug":"Linux学习笔记","date":"2016-03-24T07:53:58.000Z","updated":"2017-09-01T15:09:41.678Z","comments":true,"path":"2016/03/24/Linux学习笔记/","link":"","permalink":"http://arthas.com.cn/2016/03/24/Linux学习笔记/","excerpt":"","text":"1、Ubuntu的图形模式与字符模式切换 ctrl+alt+f2进入命令行模式 ctrl+alt+f7进入到图形模式 2、使用root终端：sudo -i 3、shutdown -t seco 设定在seco秒之后关机 -r 重启 -h 关机 man shutdown 帮助 4、软件安装包Linxu安装软件包文件有许多不同的类型。他们多数与特定Linux发行版的软件管理器相关联， Debian软件包文件为.deb （ubuntu主要包） RedHat软件包文件为.rpm Tarballs软件包文件为.tar 5、APT APT(The Advanced Packaging Tool 高级软件包工具)是一个强大的包管理系统，图形化程序如添加/删除应用程序和Synictic都是建立在其基础之上，APT会自动处理依赖关系，APT由名字以“apt-”打头的程序组成， Aptitude为一个高级包管理工具，也是目前首选的字符界面APT前端程序，它会记住哪些包是你安装的，哪些是为了满足依赖关系而安装的。在已安装包不需要的情况下，Aptitude会自动卸载后者。Aptitude完全可以作为apt-get的替代品。 APT的一些常用操作命令 查看软件的信息：sudo apt-cache showsrc 获取源代码： sudo apt-get source 安装软件包： sudo apt-get install 获取新的软件包列表： sudo apt-get update 6、安装软件Ubuntu相关的软件包文件名使用.deb作为后缀，这是因为Ubuntu和Debian发行版有着紧密的联系。dpkg(debian package)是为Debian系统专门开发的软件包。 安装软件包 1sudo dpkg -i &lt;package&gt; 删除软件包 1sudo dpkg -i &lt;package&gt; 7、alien转换包不建议安装rpm包，因为debian的包已经很多了，但是当只有rpm包的时候，又需要安装到ubuntu上的时候，就需要用alien把rpm包转换为deb包，再安装。 alien也可以指在linux下运行的一款软件。它的作用是对现有流行的linux软件发行格式——如rpm,deb,tgz等进行转换。可以帮助某一发行版的linux用户转换由其它linux发行版发行的软件来使用（如在debian上安装由fedora(Red Hat)主推的rpm格式软件），以保证软件的格式兼容。 安装alien1sudo apt-get install alien 通过alien将rpm包转换成deb包：1sudo alien package_file.rpm 生成同名的.deb文件1sudo dpkg -i package_file.deb 8、修改源备份当前的源列表文件1sudo cp -p /etc/apt/sources.list /etc/apt/sources.list_bak (ubuntu用户)用文本编辑器修改源文件1sudo gedit sources.list 注意：将不同软件源混杂在一起可能导致系统崩溃 9、更新1sudo apt-get update 这个命令（换源后必须执行），会访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑。我们在新立得软件包管理器里看到的软件列表，都是通过update命令更新的。接着： 1sudo apt-get upgrade 这个命令，会把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。upgreade可不能乱用，要是源里面有系统更新，直接会把系统升级了。 9、搜索搜索所有包含xxx的文件或文件夹1locate xxx 10、多命令执行 分号使用方式：command1 ; command2先执行command1,不管command1会不会出错，都会执行command2 &amp;&amp;使用方式：command1 &amp;&amp; command2只有当command1正确运行完毕后才执行command2 11、文件查找find命令从指定的起始目录开始，递归的搜索其各个子目录，查找满足查找条件的文件并对其采取相关操作。语法：1find [路径] [参数] 参数 -amin n : 查找n分钟以内被访问的文件 -name ‘字符串’：查找文件名匹配所给字符串的所有文件，字符串内可以用通配符？*和[] -user ‘字符串’ ： 查找属于用户名为所给字符串的所有文件 which命令基本功能是从系统变量path中指定的路径去寻找可执行文件，简单来说，其基本功能在于查找可执行文件，语法：1which [文件名称] whereis用于查找一个指定文件名的文件1whereis [-bmsu] [目录名称] 12、查看某个目录的大小1du -s [-h][-m] 默认是以k为单位的， -s : 省略子文件的显示 -h : 用人类能读懂的方式显示[human readable] -m : 以M为单位显示 13、前后台管理 &amp;用户将屏幕中的命令（command）在后台执行，可通过fg让该程序切换到前台执行 ctrl+z用户将一个前台正在执行的命令放到后台，并且暂停 jobs用来查看当前有多少命令在后台执行 14、进程管理 psps指令和top指令都用来监视系统进程和资源使用情况。ps更为常用。1ps -aux 显示所有包含其他用户的进程 top动态显示系统进程和资源信息 free [-k][-m][-h]查看当前内存情况 kill -9 pid用于杀死pid进程，和ps、pgrep结合在一起使用 whowho和w用来查看目前系统上的用户","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://arthas.com.cn/tags/linux/"}],"keywords":[]},{"title":"快速掌握Git基础操作","slug":"快速掌握Git基础操作","date":"2015-10-17T09:31:03.000Z","updated":"2017-09-02T01:49:18.726Z","comments":true,"path":"2015/10/17/快速掌握Git基础操作/","link":"","permalink":"http://arthas.com.cn/2015/10/17/快速掌握Git基础操作/","excerpt":"常用的Git命令","text":"常用的Git命令 初始化配置$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 创建版本库（初始化仓库）windows系统下仓库路径不要出现中文$git init 把文件添加到版本库 添加所有改动过的文件$git add .提交到版本库$git commit -m &quot;message&quot; 查看修改结果查看修改状态$git status查看具体修改内容`$git diff filename.txt 版本回退版本历史记录$git log --oneline --decorate --graph回退到上一个版本$ git reset --hard HEAD^重返未来$git reflog 撤销修改 未执行$git add .时，丢弃工作区的修改当还没有提交到暂存区时，会和版本库一样当提交到暂存区时，会回到添加暂存区后的状态 $git checkout -- readme.txt $git checkout -- . 执行了$git add .，但未commit把暂存区的修改撤销，重新放回工作区 $git reset HEAD file.txt 执行了commit， 版本回退 删除文件 从本地直接删除（此时工作区和版本库不一致） 确实要从版本库中删除文件 $git rm -rf test.txt $git commit -m &quot;message&quot; 删错了想恢复 $git checkout -- test.txt 远程仓库 创建SSH key 生成SSH key $ssh-keygen -t rsa -b 4096 -C &quot;your email@com&quot; 绑定在github网站 检测是否绑定成功 $ssh -T git@github.com 添加远程库 在github上新建一个仓库，如learn.git 在本地learn.git仓库中运行下列语句来关联远程库 $git remote add origin git@github.com:qinzhongjie/learngit.git 把本地仓库中所有内容推送到远程库 首次推送，-u为了关联两个仓库 $git push -u origin master 以后的推送 $git push origin master 克隆远程库 $git clone git@github.com:qinzhongjie/learngit.git 注意： .gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。 正确的做法是在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。 git update-index –assume-unchanged PATH 在PATH处输入要忽略的文件。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://arthas.com.cn/tags/git/"}],"keywords":[]}]}